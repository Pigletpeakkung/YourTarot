<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Mystical Tarot - Advanced Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;900&family=Cormorant+Garamond:wght@300;400;600&family=Poiret+One:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js"></script>
    <style>
        :root {
            --bg-color: #0a0618;
            --primary-color: #9969ff;
            --secondary-color: #ff69a1;
            --tertiary-color: #69b4ff;
            --accent-color: #ffeb3b;
            --text-color: #ffffff;
            --card-back: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #1a1a2e 75%, #16213e 100%);
            --card-front: linear-gradient(135deg, #2b2f66, #1c1647, #3f2a5c);
            --card-hover: #764ba2;
            --glitter-color: rgba(255, 235, 59, 0.9);
            --shine-color: hsla(280, 95%, 85%, 0.8);
            --tarot-gold: #ffd700;
            --tarot-silver: #c0c0c0;
            --tarot-bronze: #cd7f32;
            --env-filter: hue-rotate(0deg) saturate(1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Cormorant Garamond", serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            cursor: none;
            filter: var(--env-filter);
            transition: filter 2s ease;
        }

        /* Environment Filters */
        .env-moonlit { --env-filter: hue-rotate(10deg) saturate(1.2) brightness(0.9); }
        .env-forest { --env-filter: hue-rotate(80deg) saturate(1.5) brightness(0.8); }
        .env-cosmic { --env-filter: hue-rotate(250deg) saturate(1.8) brightness(1.1); }
        .env-temple { --env-filter: hue-rotate(30deg) saturate(1.3) brightness(1.2); }

        /* Custom Cursor Enhancement */
        .custom-cursor {
            width: 50px;
            height: 50px;
            border: 3px solid var(--shine-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(8px);
        }

        .custom-cursor.active {
            transform: scale(2.5);
            border-color: var(--accent-color);
            box-shadow: 0 0 50px var(--accent-color), inset 0 0 20px var(--accent-color);
        }

        .custom-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorPulse 2s ease-in-out infinite;
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 1px solid var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorRing 3s ease-in-out infinite;
        }

        @keyframes cursorPulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.8); }
        }

        @keyframes cursorRing {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Enhanced Environment Controls */
        .environment-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .env-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .env-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .env-btn.active {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
            animation: envActive 2s ease-in-out infinite;
        }

        @keyframes envActive {
            0%, 100% { box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 10px 40px var(--tarot-gold); }
        }

        /* Advanced Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid var(--shine-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-label {
            font-family: "Cinzel", serif;
            font-size: 0.9rem;
            color: var(--tarot-gold);
        }

        .control-slider {
            width: 200px;
            appearance: none;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            outline: none;
        }

        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--tarot-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--tarot-gold);
        }

        .control-toggle {
            width: 60px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-toggle.active {
            background: var(--primary-color);
        }

        .control-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .control-toggle.active::before {
            transform: translateX(30px);
        }

        /* Enhanced Card Preview Modal */
        .card-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
        }

        .card-preview-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .preview-content {
            width: 90%;
            max-width: 800px;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            padding: 3rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .preview-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--tarot-gold), transparent);
            animation: previewBorder 10s linear infinite;
            opacity: 0.3;
        }

        @keyframes previewBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .card-large {
            font-size: 6rem;
            margin-bottom: 1rem;
            position: relative;
            z-index: 2;
            animation: cardSymbolFloat 4s ease-in-out infinite;
        }

        @keyframes cardSymbolFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(5deg); }
            75% { transform: translateY(10px) rotate(-5deg); }
        }

        .preview-title {
            font-family: "Cinzel", serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-silver));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 2;
        }

        .meaning-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid var(--shine-color);
            position: relative;
            z-index: 2;
        }

        .meaning-title {
            font-family: "Cinzel", serif;
            font-size: 1.3rem;
            color: var(--tarot-gold);
            margin-bottom: 0.5rem;
        }

        .meaning-text {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }

        /* Voice Control Interface */
        .voice-control {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .voice-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .voice-btn.listening {
            animation: voiceListening 1s ease-in-out infinite;
        }

        .voice-btn.speaking {
            animation: voiceSpeaking 0.5s ease-in-out infinite;
        }

        @keyframes voiceListening {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
            50% { transform: scale(1.2); box-shadow: 0 20px 50px var(--tertiary-color); }
        }

        @keyframes voiceSpeaking {
            0%, 100% { background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color)); }
            50% { background: linear-gradient(45deg, var(--accent-color), var(--tertiary-color)); }
        }

        .voice-status {
            font-size: 0.8rem;
            color: var(--tarot-gold);
            text-align: center;
            opacity: 0.8;
        }

        /* AI Analysis Panel */
        .ai-analysis {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--primary-color);
            backdrop-filter: blur(15px);
            transform: translateY(100%);
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .ai-analysis.visible {
            transform: translateY(0);
        }

        .ai-title {
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            color: var(--tarot-gold);
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .ai-metric-label {
            color: var(--shine-color);
        }

        .ai-metric-value {
            color: var(--tarot-gold);
            font-weight: bold;
        }

        .ai-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 1s ease;
            border-radius: 4px;
        }

        /* Touch Gesture Indicators */
        .gesture-indicator {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 3px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 9000;
            transition: all 0.3s ease;
        }

        .gesture-indicator.active {
            opacity: 0.8;
            transform: scale(1.5);
        }

        .gesture-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: gestureRipple 1s ease-out infinite;
        }

        @keyframes gestureRipple {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Enhanced Lighting Effects */
        .lighting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                         rgba(255, 255, 255, 0.1) 0%, 
                         transparent 50%);
            transition: all 0.5s ease;
        }

        /* Performance Indicators */
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity:0;
}
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .perf-metric {
            display: inline-block;
            margin-right: 15px;
        }

        .perf-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Enhanced Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 15px;
            font-family: "Cinzel", serif;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            border: 2px solid var(--tarot-gold);
            backdrop-filter: blur(10px);
            animation: notificationSlide 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .notification::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: notificationShine 2s ease-in-out infinite;
        }

        @keyframes notificationShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .notification.success {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
        }

        .notification.warning {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .notification.error {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .notification.ai {
            background: linear-gradient(135deg, var(--tertiary-color), var(--primary-color));
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .environment-controls {
                flex-direction: row;
                top: auto;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .control-panel {
                width: 90%;
                max-width: 300px;
                right: 50%;
                transform: translateX(50%);
            }
            
            .ai-analysis {
                width: 90%;
                left: 50%;
                transform: translateX(-50%) translateY(100%);
            }
            
            .ai-analysis.visible {
                transform: translateX(-50%) translateY(0);
            }
            
            .voice-control {
                bottom: 120px;
            }
        }

        /* Canvas Enhancement */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #bg-canvas { z-index: 1; }
        #particle-canvas { z-index: 2; }
        #glitter-canvas { z-index: 3; }
        #shine-canvas { z-index: 4; }
        #lighting-canvas { z-index: 5; }
        #trail-canvas { z-index: 6; }

        /* Original styles continued... */
        .container {
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 10;
        }

        /* Enhanced Header */
        header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
            z-index: 11;
        }

        .magical-title {
            font-family: "Cinzel", serif;
            font-size: 5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--tertiary-color), var(--accent-color));
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease infinite, titleFloat 6s ease-in-out infinite;
            text-shadow: 0 0 50px rgba(153, 105, 255, 0.8);
            position: relative;
            filter: drop-shadow(0 0 30px var(--shine-color));
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes titleFloat {
            0%, 100% { 
                transform: translateY(0px) scale(1); 
                filter: brightness(1) drop-shadow(0 0 30px var(--shine-color)); 
            }
            50% { 
                transform: translateY(-10px) scale(1.02); 
                filter: brightness(1.2) drop-shadow(0 0 50px var(--shine-color)); 
            }
        }

        .subtitle {
            font-size: 1.6rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto 2rem;
            animation: subtitleGlow 4s ease-in-out infinite;
            text-shadow: 0 0 15px var(--shine-color);
        }

        @keyframes subtitleGlow {
            0%, 100% { 
                opacity: 0.8; 
                text-shadow: 0 0 15px var(--shine-color); 
            }
            50% { 
                opacity: 1; 
                text-shadow: 0 0 25px var(--shine-color); 
            }
        }

        /* Enhanced Controls */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 3rem;
            flex-wrap: wrap;
            z-index: 11;
            position: relative;
        }

        .mystical-btn {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 1.5rem 3rem;
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(153, 105, 255, 0.4);
            position: relative;
            overflow: hidden;
            transform: perspective(1000px) rotateX(0deg);
        }

        .mystical-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, var(--shine-color), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
            opacity: 0;
        }

        .mystical-btn:hover {
            transform: perspective(1000px) rotateX(10deg) translateY(-8px) scale(1.05);
            box-shadow: 0 20px 40px rgba(153, 105, 255, 0.8);
            filter: drop-shadow(0 0 20px var(--shine-color));
        }

        .mystical-btn:hover::before {
            animation: shimmer 1s ease-in-out;
        }

        .mystical-btn:active {
            transform: perspective(1000px) rotateX(5deg) translateY(-4px) scale(1.02);
        }

        .mystical-btn.shuffle {
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
        }

        .mystical-btn.tarot {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
        }

        @keyframes shimmer {
            0% { transform: translateX(-200%) translateY(-200%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(200%) translateY(200%) rotate(45deg); opacity: 0; }
        }

        /* Enhanced Card Styles */
        .card-table {
            perspective: 2000px;
            margin-bottom: 3rem;
            min-height: 600px;
            z-index: 11;
            position: relative;
        }

        .cards-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            max-width: 1400px;
            margin: 0 auto;
            padding: 3rem 2rem;
            position: relative;
        }

        .card {
            width: 140px;
            height: 240px;
            position: relative;
            transform-style: preserve-3d;
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            filter: brightness(0.9);
            border-radius: 20px;
        }

        .card:hover {
            filter: brightness(1.4) drop-shadow(0 0 30px var(--shine-color));
            transform: translateY(-30px) rotateY(15deg) rotateX(5deg) scale(1.1);
        }

        .card.selected {
            transform: scale(1.3) translateY(-50px) rotateY(10deg);
            z-index: 100;
            filter: drop-shadow(0 0 50px var(--shine-color)) brightness(1.5);
            animation: selectedGlow 2s ease-in-out infinite;
        }

        @keyframes selectedGlow {
            0%, 100% { 
                box-shadow: 0 0 30px var(--shine-color); 
            }
            50% { 
                box-shadow: 0 0 60px var(--shine-color); 
            }
        }

        .card-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            border: 2px solid var(--shine-color);
        }

        .card-back {
            background: var(--card-back);
            position: relative;
        }

        .card-front {
            background: var(--card-front);
            transform: rotateY(180deg);
            padding: 1.5rem;
            text-align: center;
            border: 2px solid var(--tarot-gold);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        /* Message Container */
        .message-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .message-container.visible {
            opacity: 1;
            pointer-events: all;
        }

        .message-card {
            width: 90%;
            max-width: 800px;
            background: rgba(15, 10, 30, 0.98);
            backdrop-filter: blur(25px);
            padding: 4rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.8);
            transform: translateY(100px) scale(0.8);
            opacity: 0;
            transition: all 1.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .message-container.visible .message-card {
            transform: translateY(0) scale(1);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="custom-cursor"></div>
    <div class="glitter-bg"></div>
    <div class="lighting-overlay"></div>
    <div class="gesture-indicator"></div>
    
    <!-- Enhanced Canvas System -->
    <canvas id="bg-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <canvas id="glitter-canvas"></canvas>
    <canvas id="shine-canvas"></canvas>
    <canvas id="lighting-canvas"></canvas>
    <canvas id="trail-canvas"></canvas>
    
    <!-- Environment Controls -->
    <div class="environment-controls">
        <button class="env-btn active" data-env="moonlit" title="Moonlit">üåô</button>
        <button class="env-btn" data-env="forest" title="Forest">üå≤</button>
        <button class="env-btn" data-env="cosmic" title="Cosmic">üåå</button>
        <button class="env-btn" data-env="temple" title="Temple">üèõÔ∏è</button>
    </div>
    
    <!-- Advanced Control Panel -->
    <div class="control-panel">
        <div class="control-group">
            <label class="control-label">Particle Intensity</label>
            <input type="range" class="control-slider" id="particle-intensity" min="0.1" max="2" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label class="control-label">Animation Speed</label>
            <input type="range" class="control-slider" id="animation-speed" min="0.5" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label class="control-label">AI Analysis</label>
            <div class="control-toggle" id="ai-toggle"></div>
        </div>
        <div class="control-group">
            <label class="control-label">Voice Control</label>
            <div class="control-toggle" id="voice-toggle"></div>
        </div>
        <div class="control-group">
            <label class="control-label">Performance Monitor</label>
            <div class="control-toggle" id="perf-toggle"></div>
        </div>
    </div>
    
    <!-- Voice Control Interface -->
    <div class="voice-control">
        <button class="voice-btn" id="voice-btn">üé§</button>
        <div class="voice-status" id="voice-status">Ready</div>
    </div>
    
    <!-- AI Analysis Panel -->
    <div class="ai-analysis" id="ai-analysis">
        <div class="ai-title">AI Insights</div>
        <div class="ai-metric">
            <span class="ai-metric-label">Reading Accuracy:</span>
            <span class="ai-metric-value" id="ai-accuracy">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-accuracy-bar"></div>
        </div>
        <div class="ai-metric">
            <span class="ai-metric-label">Elemental Balance:</span>
            <span class="ai-metric-value" id="ai-balance">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-balance-bar"></div>
        </div>
        <div class="ai-metric">
            <span class="ai-metric-label">Spiritual Resonance:</span>
            <span class="ai-metric-value" id="ai-resonance">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-resonance-bar"></div>
        </div>
    </div>
    
    <!-- Performance Monitor -->
    <div class="performance-monitor" id="performance-monitor">
        <div class="perf-metric">
            FPS: <span class="perf-value" id="fps-counter">--</span>
        </div>
        <div class="perf-metric">
            Particles: <span class="perf-value" id="particle-count">--</span>
        </div>
        <div class="perf-metric">
            Memory: <span class="perf-value" id="memory-usage">--</span>
        </div>
    </div>
    
    <!-- Notification Container -->
    <div class="notification-container" id="notification-container"></div>
    
    <!-- Loading Animation -->
    <div class="loading-animation" id="loading">
        <div class="loading-spinner"></div>
    </div>
    
    <!-- Main Content -->
    <div class="container">
        <header class="animate__animated animate__fadeInDown">
            <h1 class="magical-title">Ultimate Mystical Tarot</h1>
            <p class="subtitle">AI-Enhanced Tarot Experience with Advanced Mystical Features</p>
        </header>

        <div class="controls animate__animated animate__fadeInUp animate__delay-1s">
            <button id="shuffle-btn" class="mystical-btn shuffle">
                <span>üîÑ Shuffle Deck</span>
            </button>
            <button id="draw-cards-btn" class="mystical-btn">
                <span>‚ú® Draw Cards</span>
            </button>
            <button id="tarot-spread-btn" class="mystical-btn tarot">
                <span>üîÆ Tarot Spread</span>
            </button>
            <button id="ai-reading-btn" class="mystical-btn">
                <span>ü§ñ AI Reading</span>
            </button>
        </div>

        <div class="spread-selector" id="spread-selector" style="display: none;">
            <button class="spread-btn active" data-spread="three-card">Three Card</button>
            <button class="spread-btn" data-spread="five-card">Five Card</button>
            <button class="spread-btn" data-spread="celtic-cross">Celtic Cross</button>
        </div>

        <div class="card-table animate__animated animate__fadeInUp animate__delay-2s">
            <div class="cards-container" id="cards-container">
                <!-- Cards will be generated by JavaScript -->
            </div>
        </div>

        <!-- Card Preview Modal -->
        <div class="card-preview-modal" id="card-preview-modal">
            <div class="preview-content">
                <div class="card-large" id="preview-symbol">üîÆ</div>
                <div class="preview-title" id="preview-title">Card Title</div>
                <div class="meaning-section">
                    <div class="meaning-title">Upright Meaning</div>
                    <div class="meaning-text" id="preview-upright">Upright meaning...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Reversed Meaning</div>
                    <div class="meaning-text" id="preview-reversed">Reversed meaning...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Astrological Connection</div>
                    <div class="meaning-text" id="preview-astrology">Astrological connection...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Historical Context</div>
                    <div class="meaning-text" id="preview-history">Historical context...</div>
                </div>
                <button class="mystical-btn" onclick="closeCardPreview()">Close</button>
            </div>
        </div>

        <!-- Message Container -->
        <div class="message-container" id="message-container">
            <div class="message-card">
                <div class="message-title" id="message-title">Your Fortune</div>
                <div class="message-text" id="message-text"></div>
                <div class="fortune-details" id="fortune-details"></div>
                <div class="message-actions">
                    <button id="reshuffle-btn" class="mystical-btn">
                        <span>üîÑ New Reading</span>
                    </button>
                    <button id="save-fortune-btn" class="mystical-btn shuffle">
                        <span>üíæ Save Fortune</span>
                    </button>
                    <button id="export-btn" class="mystical-btn tarot">
                        <span>üì§ Export</span>
                    </button>
                    <button id="share-btn" class="mystical-btn">
                        <span>üì± Share</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Ultimate Mystical Tarot Application with AI Enhancement
        class UltimateMysticalTarot {
            constructor() {
                this.initializeCanvases();
                this.initializeElements();
                this.initializeData();
                this.initializeState();
                this.initializeAI();
                this.initializeAudio();
                this.initializeVoice();
                this.initializeTouchGestures();
                this.initializeEnvironments();
                this.initializePerformanceMonitor();
                this.setupEventListeners();
                this.setupCustomCursor();
                this.setupDynamicLighting();
                this.init();
            }

            // 1. AI-Powered Readings
            initializeAI() {
                this.aiEnabled = false;
                this.aiInsights = {
                    accuracy: 0,
                    balance: 0,
                    resonance: 0
                };
                
                this.cardElements = {
                    'The Fool': 'Air',
                    'The Magician': 'Air',
                    'The High Priestess': 'Water',
                    'The Empress': 'Earth',
                    'The Emperor': 'Fire',
                    'The Hierophant': 'Earth',
                    'The Lovers': 'Air',
                    'The Chariot': 'Water',
                    'Strength': 'Fire',
                    'The Hermit': 'Earth',
                    'Wheel of Fortune': 'Fire',
                    'Justice': 'Air',
                    'The Hanged Man': 'Water',
                    'Death': 'Water',
                    'Temperance': 'Fire',
                    'The Devil': 'Earth',
                    'The Tower': 'Fire',
                    'The Star': 'Air',
                    'The Moon': 'Water',
                    'The Sun': 'Fire',
                    'Judgement': 'Fire',
                    'The World': 'Earth'
                };
                
                this.cardNumerology = {
                    'The Fool': 0,
                    'The Magician': 1,
                    'The High Priestess': 2,
                    'The Empress': 3,
                    'The Emperor': 4,
                    'The Hierophant': 5,
                    'The Lovers': 6,
                    'The Chariot': 7,
                    'Strength': 8,
                    'The Hermit': 9,
                    'Wheel of Fortune': 10,
                    'Justice': 11,
                    'The Hanged Man': 12,
                    'Death': 13,
                    'Temperance': 14,
                    'The Devil': 15,
                    'The Tower': 16,
                    'The Star': 17,
                    'The Moon': 18,
                    'The Sun': 19,
                    'Judgement': 20,
                    'The World': 21
                };
            }

            generateAIReading(selectedCards) {
                if (!this.aiEnabled) return null;
                
                const elements = selectedCards.map(card => this.cardElements[card.title] || 'Unknown');
                const numbers = selectedCards.map(card => this.cardNumerology[card.title] || 0);
                
                // Calculate elemental balance
                const elementCount = elements.reduce((acc, element) => {
                    acc[element] = (acc[element] || 0) + 1;
                    return acc;
                }, {});
                
                const balance = this.calculateElementalBalance(elementCount);
                
                // Calculate numerological significance
                const numerSum = numbers.reduce((a, b) => a + b, 0);
                const numerReduced = this.reduceNumber(numerSum);
                
                // Calculate spiritual resonance
                const majorArcana = selectedCards.filter(card => card.rarity === 'major').length;
                const resonance = (majorArcana / selectedCards.length) * 100;
                
                // Calculate reading accuracy based on card synergy
                const accuracy = this.calculateCardSynergy(selectedCards);
                
                this.aiInsights = {
                    accuracy: Math.round(accuracy),
                    balance: Math.round(balance),
                    resonance: Math.round(resonance),
                    elementalDistribution: elementCount,
                    numerologicalSignificance: numerReduced,
                    recommendations: this.generateRecommendations(balance, resonance, accuracy)
                };
                
                this.updateAIPanel();
                
                return {
                    insights: this.aiInsights,
                    enhancedReading: this.generateEnhancedReading(selectedCards, this.aiInsights)
                };
            }

            calculateElementalBalance(elementCount) {
                const total = Object.values(elementCount).reduce((a, b) => a + b, 0);
                const expected = total / 4; // Perfect balance
                const variance = Object.values(elementCount).reduce((acc, count) => {
                    return acc + Math.pow(count - expected, 2);
                }, 0);
                return Math.max(0, 100 - (variance / expected) * 25);
            }

            reduceNumber(num) {
                while (num > 9) {
                    num = num.toString().split('').reduce((a, b) => parseInt(a) + parseInt(b), 0);
                }
                return num;
            }

            calculateCardSynergy(cards) {
                let synergy = 50; // Base synergy
                
                // Check for complementary cards
                const elements = cards.map(card => this.cardElements[card.title]);
                const uniqueElements = [...new Set(elements)];
                
                if (uniqueElements.length === cards.length) {
                    synergy += 20; // Diverse elements
                } else if (uniqueElements.length === 1) {
                    synergy += 15; // Unified element
                }
                
                // Check for sequential numbers
                const numbers = cards.map(card => this.cardNumerology[card.title]).sort((a, b) => a - b);
                for (let i = 0; i < numbers.length - 1; i++) {
                    if (numbers[i + 1] - numbers[i] === 1) {
                        synergy += 10; // Sequential bonus
                    }
                }
                
                return Math.min(100, synergy);
            }

            generateRecommendations(balance, resonance, accuracy) {
                const recommendations = [];
                
                if (balance < 50) {
                    recommendations.push("Focus on balancing different aspects of your life");
                }
                if (resonance > 70) {
                    recommendations.push("Major life themes are prominent - pay attention to spiritual messages");
                }
                if (accuracy > 80) {
                    recommendations.push("The cards are in strong harmony - trust the guidance");
                }
                
                return recommendations;
            }

            generateEnhancedReading(cards, insights) {
                const baseReading = cards.map(card => card.fortune).join(' ');
                const enhancement = `\n\nAI Analysis: Your reading shows ${insights.accuracy}% accuracy with ${insights.balance}% elemental balance. The spiritual resonance is ${insights.resonance}%, indicating ${insights.resonance > 70 ? 'strong' : 'moderate'} spiritual significance.`;
                
                return baseReading + enhancement;
            }

            updateAIPanel() {
                if (!this.aiEnabled) return;
                
                document.getElementById('ai-accuracy').textContent = this.aiInsights.accuracy + '%';
                document.getElementById('ai-balance').textContent = this.aiInsights.balance + '%';
                document.getElementById('ai-resonance').textContent = this.aiInsights.resonance + '%';
                
                document.getElementById('ai-accuracy-bar').style.width = this.aiInsights.accuracy + '%';
                document.getElementById('ai-balance-bar').style.width = this.aiInsights.balance + '%';
                document.getElementById('ai-resonance-bar').style.width = this.aiInsights.resonance + '%';
                
                document.getElementById('ai-analysis').classList.add('visible');
            }

            // 2. Immersive Environments
            initializeEnvironments() {
                this.currentEnvironment = 'moonlit';
                this.environments = {
                    moonlit: {
                        particles: '#c0c0ff',
                        glitter: '#e6e6ff',
                        shine: '#ffffff',
                        filter: 'hue-rotate(10deg) saturate(1.2) brightness(0.9)',
                        ambientColor: 'rgba(192, 192, 255, 0.1)'
                    },
                    forest: {
                        particles: '#90EE90',
                        glitter: '#32CD32',
                        shine: '#ADFF2F',
                        filter: 'hue-rotate(80deg) saturate(1.5) brightness(0.8)',
                        ambientColor: 'rgba(144, 238, 144, 0.1)'
                    },
                    cosmic: {
                        particles: '#FF1493',
                        glitter: '#00BFFF',
                        shine: '#FFD700',
                        filter: 'hue-rotate(250deg) saturate(1.8) brightness(1.1)',
                        ambientColor: 'rgba(255, 20, 147, 0.1)'
                    },
                    temple: {
                        particles: '#FFD700',
                        glitter: '#FFA500',
                        shine: '#FFFF00',
                        filter: 'hue-rotate(30deg) saturate(1.3) brightness(1.2)',
                        ambientColor: 'rgba(255, 215, 0, 0.1)'
                    }
                };
            }

            switchEnvironment(envName) {
                this.currentEnvironment = envName;
                const env = this.environments[envName];
                
                // Update CSS variables
                document.documentElement.style.setProperty('--env-filter', env.filter);
                
                // Update particle colors
                this.updateParticleColors(env);
                
                // Update lighting
                this.updateAmbientLighting(env.ambientColor);
                
                // Update UI
                document.querySelectorAll('.env-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-env="${envName}"]`).classList.add('active');
                
                this.showNotification(`Environment changed to ${envName.charAt(0).toUpperCase() + envName.slice(1)}`, 'success');
            }

            updateParticleColors(env) {
                this.particleColors = [env.particles, env.glitter, env.shine];
                
                // Update existing particles
                this.particles.forEach(particle => {
                    particle.color = this.particleColors[Math.floor(Math.random() * this.particleColors.length)];
                });
                
                this.glitterParticles.forEach(particle => {
                    particle.color = env.glitter;
                });
                
                this.shineParticles.forEach(particle => {
                    particle.color = env.shine;
                });
            }

            updateAmbientLighting(color) {
                const lightingOverlay = document.querySelector('.lighting-overlay');
                const mouseX = (this.mousePos.x / window.innerWidth) * 100;
                const mouseY = (this.mousePos.y / window.innerHeight) * 100;
                
                lightingOverlay.style.background = `radial-gradient(circle at ${mouseX}% ${mouseY}%, ${color} 0%, transparent 50%)`;
            }

            // 3. Enhanced Card Interactions
            showCardPreview(card) {
                const modal = document.getElementById('card-preview-modal');
                const extendedCard = this.getExtendedCardData(card);
                
                document.getElementById('preview-symbol').textContent = card.symbol;
                document.getElementById('preview-title').textContent = card.title;
                document.getElementById('preview-upright').textContent = extendedCard.upright;
                document.getElementById('preview-reversed').textContent = extendedCard.reversed;
                document.getElementById('preview-astrology').textContent = extendedCard.astrology;
                document.getElementById('preview-history').textContent = extendedCard.history;
                
                modal.classList.add('visible');
                
                // Create preview particles
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'preview'
                        );
                    }, i * 100);
                }
            }

            getExtendedCardData(card) {
                const extended = {
                    upright: card.fortune,
                    reversed: this.getReversedMeaning(card.title),
                    astrology: this.getAstrologicalConnection(card.title),
                    history: this.getHistoricalContext(card.title)
                };
                
                return extended;
            }

            getReversedMeaning(cardTitle) {
                const reversedMeanings = {
                    'The Star': 'Self-doubt, lack of faith, pessimism, disconnection from higher purpose',
                    'The Moon': 'Overcoming fear, finding truth, released illusions, clarity emerging',
                    'The Sun': 'Temporary setbacks, lack of enthusiasm, delayed success, inner child healing needed',
                    'The Tower': 'Avoiding disaster, delaying the inevitable, internal transformation',
                    'The Magician': 'Manipulation, untapped potential, lack of willpower, scattered energy',
                    'The High Priestess': 'Hidden motives, superficial knowledge, ignoring intuition',
                    'The Empress': 'Neglecting self-care, creative blocks, lack of growth',
                    'The Emperor': 'Abuse of power, lack of control, avoiding responsibility',
                    'The Hierophant': 'Challenging tradition, freedom from conformity, personal beliefs',
                    'The Lovers': 'Relationship issues, misaligned values, inner conflict',
                    'Temperance': 'Imbalance, extremes, lack of moderation, rushed decisions',
                    'The Fool': 'Recklessness, holding back, fear of the unknown'
                };
                
                return reversedMeanings[cardTitle] || 'Reversed energy of this card suggests internal work needed';
            }

                        getHistoricalContext(cardTitle) {
                const historicalContext = {
                    'The Star': 'Ancient symbol of divine guidance, featured in Egyptian and Greek mythology as connection to celestial wisdom',
                    'The Moon': 'Represents the Triple Goddess in many traditions, symbolizing maiden, mother, and crone aspects',
                    'The Sun': 'Solar deities across cultures - Ra, Apollo, Helios - representing consciousness and enlightenment',
                    'The Tower': 'Tower of Babel archetype, representing hubris and divine intervention',
                    'The Magician': 'Hermetic tradition of "as above, so below" - mastery over elements and manifestation',
                    'The High Priestess': 'Temple mysteries of ancient Egypt and Greece, keeper of sacred knowledge',
                    'The Empress': 'Earth Mother archetype found in cultures worldwide - Demeter, Gaia, Pachamama',
                    'The Emperor': 'Divine kingship concept from ancient civilizations - pharaohs, caesars, mandates of heaven',
                    'The Hierophant': 'Spiritual teacher role in mystery schools and religious traditions',
                    'The Lovers': 'Sacred marriage concept in alchemy and mysticism, union of opposites',
                    'Temperance': 'Alchemical process of solve et coagula - dissolution and coagulation',
                    'The Fool': 'Holy fool tradition in many cultures, divine wisdom through innocence'
                };
                
                return historicalContext[cardTitle] || 'Rich symbolic history spanning multiple mystical traditions';
            }

            closeCardPreview() {
                document.getElementById('card-preview-modal').classList.remove('visible');
            }

            // 4. Advanced Particle Physics
            initializeAdvancedParticles() {
                this.particlePool = [];
                this.forceFields = [];
                this.attractors = [];
                this.magneticFields = [];
                
                // Create particle pool for performance
                for (let i = 0; i < 1000; i++) {
                    this.particlePool.push(this.createEmptyParticle());
                }
            }

            createEmptyParticle() {
                return {
                    x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0,
                    active: false, type: '', rotation: 0, rotationSpeed: 0,
                    alpha: 1, trail: [], mass: 1, charge: 0
                };
            }

            getParticleFromPool() {
                return this.particlePool.find(p => !p.active) || this.createEmptyParticle();
            }

            createMagneticField(x, y, strength, polarity = 1) {
                this.magneticFields.push({
                    x, y, strength, polarity,
                    affect: (particle) => {
                        const dx = x - particle.x;
                        const dy = y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            const force = (strength * polarity) / (distance * distance);
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            particle.vx += forceX * particle.charge;
                            particle.vy += forceY * particle.charge;
                        }
                    }
                });
            }

            createParticleTrail(startX, startY, endX, endY, particleCount = 20) {
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    
                    setTimeout(() => {
                        const particle = this.getParticleFromPool();
                        this.initializeParticle(particle, x, y, 'trail');
                        particle.charge = Math.random() > 0.5 ? 1 : -1;
                    }, i * 50);
                }
            }

            applyForceFields() {
                this.particles.forEach(particle => {
                    this.magneticFields.forEach(field => {
                        field.affect(particle);
                    });
                    
                    // Apply physics
                    particle.vx *= 0.99; // Air resistance
                    particle.vy *= 0.99;
                    particle.vy += 0.05; // Gravity
                });
            }

            // 5. Dynamic Lighting System
            setupDynamicLighting() {
                this.lightingCanvas = document.getElementById('lighting-canvas');
                this.lightingCtx = this.lightingCanvas.getContext('2d');
                this.lights = [];
                this.shadows = [];
                this.ambientIntensity = 0.3;
                
                // Add initial lights
                this.addPointLight(window.innerWidth / 2, window.innerHeight / 2, '255, 255, 255', 0.5, 300);
                this.addPointLight(100, 100, '153, 105, 255', 0.3, 200);
                this.addPointLight(window.innerWidth - 100, 100, '255, 105, 153', 0.3, 200);
                
                this.animateLighting();
            }

            addPointLight(x, y, color, intensity, radius) {
                this.lights.push({
                    x, y, color, intensity, radius,
                    originalIntensity: intensity,
                    flicker: Math.random() * 0.1 + 0.9,
                    flickerSpeed: Math.random() * 0.01 + 0.005,
                    time: 0,
                    update: function() {
                        this.time += this.flickerSpeed;
                        this.flicker = Math.sin(this.time) * 0.1 + 0.9;
                        this.intensity = this.originalIntensity * this.flicker;
                    }
                });
            }

            animateLighting() {
                this.lightingCtx.clearRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                
                // Update mouse light position
                if (this.lights.length > 0) {
                    this.lights[0].x = this.mousePos.x;
                    this.lights[0].y = this.mousePos.y;
                }
                
                // Update all lights
                this.lights.forEach(light => light.update());
                
                // Render lighting
                this.renderLighting();
                
                requestAnimationFrame(() => this.animateLighting());
            }

            renderLighting() {
                // Create ambient darkness
                this.lightingCtx.globalCompositeOperation = 'source-over';
                this.lightingCtx.fillStyle = `rgba(0, 0, 0, ${1 - this.ambientIntensity})`;
                this.lightingCtx.fillRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                
                // Add light sources
                this.lightingCtx.globalCompositeOperation = 'screen';
                this.lights.forEach(light => {
                    const gradient = this.lightingCtx.createRadialGradient(
                        light.x, light.y, 0,
                        light.x, light.y, light.radius
                    );
                    gradient.addColorStop(0, `rgba(${light.color}, ${light.intensity})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    this.lightingCtx.fillStyle = gradient;
                    this.lightingCtx.fillRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                });
            }

            // 6. Spatial Audio & Music
            initializeAudio() {
                this.audioEnabled = true;
                this.audioContext = null;
                this.spatialAudio = null;
                this.masterGain = null;
                this.convolver = null;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.spatialAudio = this.audioContext.createPanner();
                    this.convolver = this.audioContext.createConvolver();
                    
                    // Setup spatial audio
                    this.spatialAudio.panningModel = 'HRTF';
                    this.spatialAudio.distanceModel = 'inverse';
                    this.spatialAudio.refDistance = 1;
                    this.spatialAudio.maxDistance = 10000;
                    this.spatialAudio.rolloffFactor = 1;
                    
                    // Connect audio graph
                    this.masterGain.connect(this.spatialAudio);
                    this.spatialAudio.connect(this.convolver);
                    this.convolver.connect(this.audioContext.destination);
                    
                    this.masterGain.gain.value = 0.3;
                    
                    // Load reverb impulse
                    this.loadReverbImpulse();
                    
                } catch (error) {
                    console.warn("Enhanced audio not supported:", error);
                    this.audioEnabled = false;
                }
            }

            loadReverbImpulse() {
                // Create synthetic reverb impulse
                const length = this.audioContext.sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.convolver.buffer = impulse;
            }

            create3DAudio(x, y, z, frequency, duration) {
                if (!this.audioEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Position audio in 3D space
                this.spatialAudio.positionX.value = x;
                this.spatialAudio.positionY.value = y;
                this.spatialAudio.positionZ.value = z;
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            generateProceduralMusic() {
                const scales = {
                    mystical: [261.63, 293.66, 329.63, 392.00, 440.00, 493.88],
                    ethereal: [256, 288, 320, 384, 432, 480],
                    cosmic: [220, 247, 277, 311, 349, 392]
                };
                
                const scale = scales[this.currentEnvironment] || scales.mystical;
                
                // Play ambient arpeggios
                this.playArpeggio(scale, 3000);
                
                // Schedule next musical phrase
                setTimeout(() => this.generateProceduralMusic(), 8000 + Math.random() * 4000);
            }

            playArpeggio(scale, duration) {
                if (!this.audioEnabled) return;
                
                scale.forEach((frequency, index) => {
                    setTimeout(() => {
                        this.create3DAudio(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            Math.random() * 100 - 50,
                            frequency,
                            duration / scale.length
                        );
                    }, index * (duration / scale.length) * 0.8);
                });
            }

            // 7. Voice Integration
            initializeVoice() {
                this.voiceEnabled = false;
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.voiceStatus = 'Ready';
                
                if ('webkitSpeechRecognition' in window) {
                    this.recognition = new webkitSpeechRecognition();
                    this.setupVoiceRecognition();
                } else if ('SpeechRecognition' in window) {
                    this.recognition = new SpeechRecognition();
                    this.setupVoiceRecognition();
                } else {
                    console.warn("Speech recognition not supported");
                }
            }

            setupVoiceRecognition() {
                if (!this.recognition) return;
                
                this.recognition.continuous = false;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';
                
                this.recognition.onstart = () => {
                    this.voiceStatus = 'Listening...';
                    this.updateVoiceStatus();
                    document.getElementById('voice-btn').classList.add('listening');
                };
                
                this.recognition.onend = () => {
                    this.voiceStatus = 'Ready';
                    this.updateVoiceStatus();
                    document.getElementById('voice-btn').classList.remove('listening');
                };
                
                this.recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase();
                    this.processVoiceCommand(command);
                };
                
                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.voiceStatus = 'Error';
                    this.updateVoiceStatus();
                };
            }

            processVoiceCommand(command) {
                console.log('Voice command:', command);
                
                if (command.includes('shuffle')) {
                    this.shuffleDeck();
                    this.speakResponse("Shuffling the deck for you");
                } else if (command.includes('draw')) {
                    this.drawCards();
                    this.speakResponse("Drawing your cards");
                } else if (command.includes('reading')) {
                    this.generateAIReading(this.selectedCards);
                    this.speakResponse("Generating AI reading");
                } else if (command.includes('environment')) {
                    if (command.includes('forest')) {
                        this.switchEnvironment('forest');
                    } else if (command.includes('cosmic')) {
                        this.switchEnvironment('cosmic');
                    } else if (command.includes('temple')) {
                        this.switchEnvironment('temple');
                    } else {
                        this.switchEnvironment('moonlit');
                    }
                } else {
                    this.speakResponse("I didn't understand that command. Try saying shuffle, draw, or reading.");
                }
            }

            speakResponse(text) {
                if (!this.synthesis) return;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.8;
                utterance.pitch = 0.9;
                utterance.voice = this.findMysticalVoice();
                
                utterance.onstart = () => {
                    document.getElementById('voice-btn').classList.add('speaking');
                };
                
                utterance.onend = () => {
                    document.getElementById('voice-btn').classList.remove('speaking');
                };
                
                this.synthesis.speak(utterance);
            }

            findMysticalVoice() {
                const voices = this.synthesis.getVoices();
                return voices.find(voice => 
                    voice.name.includes('Female') || 
                    voice.name.includes('Samantha') ||
                    voice.name.includes('Serena')
                ) || voices[0];
            }

            updateVoiceStatus() {
                document.getElementById('voice-status').textContent = this.voiceStatus;
            }

            startVoiceRecognition() {
                if (!this.recognition || !this.voiceEnabled) return;
                
                try {
                    this.recognition.start();
                } catch (error) {
                    console.error('Voice recognition error:', error);
                }
            }

            // 8. Advanced Touch Interactions
            initializeTouchGestures() {
                this.gestureRecognizer = new GestureRecognizer();
                this.setupGestures();
            }

            setupGestures() {
                let startY = 0;
                let startX = 0;
                let startTime = 0;
                
                document.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                    startX = e.touches[0].clientX;
                    startTime = Date.now();
                    
                    this.showGestureIndicator(startX, startY);
                });
                
                document.addEventListener('touchmove', (e) => {
                    const currentY = e.touches[0].clientY;
                    const currentX = e.touches[0].clientX;
                    const deltaY = startY - currentY;
                    const deltaX = startX - currentX;
                    
                    if (Math.abs(deltaY) > 50 || Math.abs(deltaX) > 50) {
                        this.updateGestureIndicator(currentX, currentY);
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', (e) => {
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    const endY = e.changedTouches[0].clientY;
                    const endX = e.changedTouches[0].clientX;
                    const deltaY = startY - endY;
                    const deltaX = startX - endX;
                    
                    this.hideGestureIndicator();
                    
                    if (duration > 1000) {
                        this.handleLongPress(endX, endY);
                    } else if (Math.abs(deltaY) > 100) {
                        if (deltaY > 0) {
                            this.handleSwipeUp(endX, endY);
                        } else {
                            this.handleSwipeDown(endX, endY);
                        }
                    } else if (Math.abs(deltaX) > 100) {
                        if (deltaX > 0) {
                            this.handleSwipeLeft(endX, endY);
                        } else {
                            this.handleSwipeRight(endX, endY);
                        }
                    }
                });
            }

            showGestureIndicator(x, y) {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.style.left = (x - 50) + 'px';
                indicator.style.top = (y - 50) + 'px';
                indicator.classList.add('active');
            }

            updateGestureIndicator(x, y) {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.style.left = (x - 50) + 'px';
                indicator.style.top = (y - 50) + 'px';
            }

            hideGestureIndicator() {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.classList.remove('active');
            }

            handleSwipeUp(x, y) {
                this.revealCard(x, y);
                this.addHapticFeedback('reveal');
            }

            handleSwipeDown(x, y) {
                this.shuffleDeck();
                this.addHapticFeedback('shuffle');
            }

            handleSwipeLeft(x, y) {
                this.previousEnvironment();
                this.addHapticFeedback('select');
            }

            handleSwipeRight(x, y) {
                this.nextEnvironment();
                this.addHapticFeedback('select');
            }

            handleLongPress(x, y) {
                this.showContextMenu(x, y);
                this.addHapticFeedback('menu');
            }

            addHapticFeedback(type) {
                if (!navigator.vibrate) return;
                
                const patterns = {
                    shuffle: [100, 50, 100, 50, 100],
                    flip: [200],
                    select: [50, 25, 50],
                    reveal: [300, 100, 300],
                    menu: [50, 50, 50]
                };
                
                navigator.vibrate(patterns[type] || [100]);
            }

            // 9. AI Accessibility
            initializeAccessibility() {
                this.screenReader = new ScreenReaderEnhancer();
                this.colorBlindness = new ColorBlindnessAdapter();
                this.motionSensitivity = new MotionAdapter();
                this.highContrast = false;
                this.reducedMotion = false;
            }

            describeCard(card) {
                const description = `${card.title}, symbolized by ${card.symbol}. ${card.description}. 
                    Upright meaning: ${card.fortune}. 
                    This card represents themes of ${card.symbolism || 'mystery and guidance'}.
                    Element: ${this.cardElements[card.title] || 'Universal'}.
                    Numerology: ${this.cardNumerology[card.title] || 'Variable'}.`;
                
                return description;
            }

            announceForScreenReader(text) {
                const announcement = document.createElement('div');
                announcement.setAttribute('aria-live', 'polite');
                announcement.setAttribute('aria-atomic', 'true');
                announcement.style.position = 'absolute';
                announcement.style.left = '-10000px';
                announcement.style.width = '1px';
                announcement.style.height = '1px';
                announcement.style.overflow = 'hidden';
                announcement.textContent = text;
                
                document.body.appendChild(announcement);
                
                setTimeout(() => {
                    document.body.removeChild(announcement);
                }, 1000);
            }

            toggleHighContrast() {
                this.highContrast = !this.highContrast;
                document.body.classList.toggle('high-contrast', this.highContrast);
            }

            toggleReducedMotion() {
                this.reducedMotion = !this.reducedMotion;
                document.body.classList.toggle('reduced-motion', this.reducedMotion);
                
                if (this.reducedMotion) {
                    this.animationSpeed = 0.3;
                } else {
                    this.animationSpeed = 1;
                }
            }

            // 10. Performance Optimization
            initializePerformanceMonitor() {
                this.performanceMonitor = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: performance.now(),
                    memoryUsage: 0,
                    particleCount: 0,
                    enabled: false
                };
                
                this.deviceCapabilities = this.detectDeviceCapabilities();
                this.optimizeForDevice();
            }

            detectDeviceCapabilities() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                let gpu = 'medium';
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        if (renderer.includes('Intel')) gpu = 'low';
                        if (renderer.includes('NVIDIA') || renderer.includes('AMD')) gpu = 'high';
                    }
                }
                
                return {
                    gpu: gpu,
                    memory: navigator.deviceMemory || 4,
                    hardwareConcurrency: navigator.hardwareConcurrency || 4,
                    connection: navigator.connection?.effectiveType || '4g'
                };
            }

            optimizeForDevice() {
                if (this.deviceCapabilities.gpu === 'low') {
                    this.maxParticles = 150;
                    this.animationQuality = 'low';
                } else if (this.deviceCapabilities.gpu === 'high') {
                    this.maxParticles = 500;
                    this.animationQuality = 'high';
                } else {
                    this.maxParticles = 300;
                    this.animationQuality = 'medium';
                }
                
                if (this.deviceCapabilities.memory < 4) {
                    this.maxParticles = Math.floor(this.maxParticles * 0.7);
                }
            }

            updatePerformanceMetrics() {
                if (!this.performanceMonitor.enabled) return;
                
                const now = performance.now();
                this.performanceMonitor.frameCount++;
                
                if (now - this.performanceMonitor.lastTime >= 1000) {
                    this.performanceMonitor.fps = this.performanceMonitor.frameCount;
                    this.performanceMonitor.frameCount = 0;
                    this.performanceMonitor.lastTime = now;
                    
                    if (performance.memory) {
                        this.performanceMonitor.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    }
                    
                    this.performanceMonitor.particleCount = this.particles.length + this.glitterParticles.length + this.shineParticles.length;
                    
                    this.updatePerformanceDisplay();
                }
            }

            updatePerformanceDisplay() {
                document.getElementById('fps-counter').textContent = this.performanceMonitor.fps;
                document.getElementById('particle-count').textContent = this.performanceMonitor.particleCount;
                document.getElementById('memory-usage').textContent = this.performanceMonitor.memoryUsage + ' MB';
                
                // Auto-optimize based on performance
                if (this.performanceMonitor.fps < 30 && this.maxParticles > 100) {
                    this.maxParticles = Math.floor(this.maxParticles * 0.9);
                    this.showNotification('Performance optimized', 'warning');
                }
            }

            // 11. Machine Learning Integration
            initializeMachineLearning() {
                this.mlEnabled = false;
                this.model = null;
                this.trainingData = [];
                this.predictions = [];
                
                // Initialize TensorFlow.js model
                this.buildModel();
            }

            async buildModel() {
                try {
                    this.model = tf.sequential({
                        layers: [
                            tf.layers.dense({
                                inputShape: [78], // 78 tarot cards
                                units: 128,
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({
                                units: 64,
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({
                                units: 32,
                                activation: 'relu'
                            }),
                            tf.layers.dense({
                                units: 1,
                                activation: 'sigmoid'
                            })
                        ]
                    });
                    
                    this.model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });
                    
                    this.mlEnabled = true;
                    console.log('ML model initialized');
                } catch (error) {
                    console.error('ML initialization failed:', error);
                }
            }

            async predictReadingAccuracy(cards, userFeedback = null) {
                if (!this.mlEnabled || !this.model) return 0.5;
                
                try {
                    const input = this.encodeCards(cards);
                    const prediction = await this.model.predict(input).data();
                    
                    if (userFeedback !== null) {
                        this.addTrainingData(input, userFeedback);
                    }
                    
                    return prediction[0];
                } catch (error) {
                    console.error('Prediction error:', error);
                    return 0.5;
                }
            }

            encodeCards(cards) {
                const encoded = new Array(78).fill(0);
                cards.forEach(card => {
                    const index = this.getCardIndex(card.title);
                    if (index >= 0) encoded[index] = 1;
                });
                return tf.tensor2d([encoded]);
            }

            getCardIndex(cardTitle) {
                const cardNames = Object.keys(this.cardNumerology);
                return cardNames.indexOf(cardTitle);
            }

            addTrainingData(input, feedback) {
                this.trainingData.push({
                    input: input,
                    output: feedback > 0.5 ? 1 : 0
                });
                
                // Retrain model periodically
                if (this.trainingData.length >= 10) {
                    this.retrainModel();
                }
            }

            async retrainModel() {
                if (this.trainingData.length < 5) return;
                
                try {
                    const inputs = tf.stack(this.trainingData.map(d => d.input));
                    const outputs = tf.tensor2d(this.trainingData.map(d => [d.output]));
                    
                    await this.model.fit(inputs, outputs, {
                        epochs: 5,
                        batchSize: 5,
                        verbose: 0
                    });
                    
                    console.log('Model retrained with', this.trainingData.length, 'samples');
                    this.trainingData = []; // Clear training data
                } catch (error) {
                    console.error('Retraining error:', error);
                }
            }

            // 12. Social & Community Features
            initializeCommunityFeatures() {
                this.communityEnabled = false;
                this.firebaseConfig = {
                    // Add your Firebase config here
                };
                
                // Initialize Firebase if config is provided
                if (this.firebaseConfig.apiKey) {
                    this.initializeFirebase();
                }
            }

            initializeFirebase() {
                try {
                    firebase.initializeApp(this.firebaseConfig);
                    this.database = firebase.database();
                    this.auth = firebase.auth();
                    this.communityEnabled = true;
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                }
            }

            async shareReading(reading) {
                const shareData = {
                    type: 'tarot-reading',
                    cards: reading.cards.map(c => ({ title: c.title, symbol: c.symbol })),
                    interpretation: reading.interpretation,
                    timestamp: Date.now(),
                    anonymous: true,
                    environment: this.currentEnvironment
                };
                
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'My Mystical Tarot Reading',
                            text: reading.interpretation,
                            url: window.location.href
                        });
                        this.showNotification('Reading shared successfully!', 'success');
                    } catch (error) {
                        this.fallbackShare(shareData);
                    }
                } else {
                    this.fallbackShare(shareData);
                }
            }

            fallbackShare(shareData) {
                const shareText = `Check out my tarot reading:\n\n${shareData.interpretation}`;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareText);
                    this.showNotification('Reading copied to clipboard!', 'success');
                } else {
                    // Create temporary textarea for copying
                    const textarea = document.createElement('textarea');
                    textarea.value = shareText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    this.showNotification('Reading copied to clipboard!', 'success');
                }
            }

            async saveToCloud(reading) {
                if (!this.communityEnabled) return;
                
                try {
                    await this.database.ref('readings').push({
                        cards: reading.cards,
                        interpretation: reading.interpretation,
                        timestamp: Date.now(),
                        environment: this.currentEnvironment,
                        aiInsights: this.aiInsights
                    });
                    
                    this.showNotification('Reading saved to cloud!', 'success');
                } catch (error) {
                    console.error('Cloud save error:', error);
                    this.showNotification('Failed to save to cloud', 'error');
                }
            }

            // Continue with enhanced initialization and setup methods...
            initializeCanvases() {
                this.bgCanvas = document.getElementById('bg-canvas');
                this.canvas = document.getElementById('particle-canvas');
                this.glitterCanvas = document.getElementById('glitter-canvas');
                this.shineCanvas = document.getElementById('shine-canvas');
                this.trailCanvas = document.getElementById('trail-canvas');
                
                this.bgCtx = this.bgCanvas.getContext('2d');
                this.ctx = this.canvas.getContext('2d');
                this.glitterCtx = this.glitterCanvas.getContext('2d');
                this.shineCtx = this.shineCanvas.getContext('2d');
                this.trailCtx = this.trailCanvas.getContext('2d');
                
                this.setupCanvas();
            }

            initializeElements() {
                this.cardsContainer = document.getElementById("cards-container");
                this.messageContainer = document.getElementById("message-container");
                this.messageTitle = document.getElementById("message-title");
                this.messageText = document.getElementById("message-text");
                this.fortuneDetails = document.getElementById("fortune-details");
                this.drawCardsBtn = document.getElementById("draw-cards-btn");
                this.reshuffleBtn = document.getElementById("reshuffle-btn");
                this.shuffleBtn = document.getElementById("shuffle-btn");
                this.tarotSpreadBtn = document.getElementById("tarot-spread-btn");
                this.saveFortuneBtn = document.getElementById("save-fortune-btn");
                this.exportBtn = document.getElementById("export-btn");
                this.shareBtn = document.getElementById("share-btn");
                this.aiReadingBtn = document.getElementById("ai-reading-btn");
                this.loadingElement = document.getElementById("loading");
                this.spreadSelector = document.getElementById("spread-selector");
                this.customCursor = document.querySelector(".custom-cursor");
            }

            setupEventListeners() {
                // Original event listeners
                this.shuffleBtn.addEventListener('click', () => this.shuffleDeck());
                this.drawCardsBtn.addEventListener('click', () => this.drawCards());
                this.tarotSpreadBtn.addEventListener('click', () => this.toggleSpreadSelector());
                this.reshuffleBtn.addEventListener('click', () => this.reshuffleCards());
                this.saveFortuneBtn.addEventListener('click', () => this.saveFortune());
                this.exportBtn.addEventListener('click', () => this.exportFortunes());
                this.shareBtn.addEventListener('click', () => this.shareCurrentReading());
                this.aiReadingBtn.addEventListener('click', () => this.generateAIReading(this.selectedCards));
                
                // Enhanced controls
                document.getElementById('particle-intensity').addEventListener('input', (e) => {
                    this.particleIntensity = parseFloat(e.target.value);
                });
                
                document.getElementById('animation-speed').addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('ai-toggle').addEventListener('click', () => {
                    this.toggleAI();
                });
                
                document.getElementById('voice-toggle').addEventListener('click', () => {
                    this.toggleVoice();
                });
                
                document.getElementById('perf-toggle').addEventListener('click', () => {
                    this.togglePerformanceMonitor();
                });
                
                document.getElementById('voice-btn').addEventListener('click', () => {
                    this.startVoiceRecognition();
                });
                
                // Environment controls
                document.querySelectorAll('.env-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.switchEnvironment(e.target.dataset.env);
                    });
                });
                
                // Spread selector
                document.querySelectorAll('.spread-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.spread-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentSpread = e.target.dataset.spread;
                    });
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeCardPreview();
                        if (this.isRevealed) this.reshuffleCards();
                    }
                    if (e.key === ' ' && !this.isRevealed) {
                        e.preventDefault();
                        this.shuffleDeck();
                    }
                    if (e.key === 'Enter' && !this.isRevealed) {
                        this.drawCards();
                    }
                    if (e.key === 'a' && e.ctrlKey) {
                        e.preventDefault();
                        this.toggleAI();
                    }
                    if (e.key === 'v' && e.ctrlKey) {
                        e.preventDefault();
                        this.toggleVoice();
                    }
                });
            }

            // Toggle functions for enhanced controls
                        toggleAI() {
                this.aiEnabled = !this.aiEnabled;
                document.getElementById('ai-toggle').classList.toggle('active', this.aiEnabled);
                
                if (this.aiEnabled) {
                    this.showNotification('AI Analysis enabled', 'success');
                    document.getElementById('ai-analysis').classList.add('visible');
                } else {
                    this.showNotification('AI Analysis disabled', 'warning');
                    document.getElementById('ai-analysis').classList.remove('visible');
                }
            }

            toggleVoice() {
                this.voiceEnabled = !this.voiceEnabled;
                document.getElementById('voice-toggle').classList.toggle('active', this.voiceEnabled);
                
                if (this.voiceEnabled) {
                    this.showNotification('Voice Control enabled - Try saying "shuffle" or "draw"', 'success');
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                } else {
                    this.showNotification('Voice Control disabled', 'warning');
                }
            }

            togglePerformanceMonitor() {
                this.performanceMonitor.enabled = !this.performanceMonitor.enabled;
                document.getElementById('perf-toggle').classList.toggle('active', this.performanceMonitor.enabled);
                
                const monitor = document.getElementById('performance-monitor');
                if (this.performanceMonitor.enabled) {
                    monitor.classList.add('visible');
                    this.showNotification('Performance Monitor enabled', 'success');
                } else {
                    monitor.classList.remove('visible');
                    this.showNotification('Performance Monitor disabled', 'warning');
                }
            }

            // Environment navigation
            previousEnvironment() {
                const envs = Object.keys(this.environments);
                const currentIndex = envs.indexOf(this.currentEnvironment);
                const prevIndex = (currentIndex - 1 + envs.length) % envs.length;
                this.switchEnvironment(envs[prevIndex]);
            }

            nextEnvironment() {
                const envs = Object.keys(this.environments);
                const currentIndex = envs.indexOf(this.currentEnvironment);
                const nextIndex = (currentIndex + 1) % envs.length;
                this.switchEnvironment(envs[nextIndex]);
            }

            // Context menu for long press
            showContextMenu(x, y) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.position = 'fixed';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.style.background = 'rgba(0, 0, 0, 0.9)';
                menu.style.borderRadius = '10px';
                menu.style.padding = '10px';
                menu.style.zIndex = '10000';
                menu.style.backdropFilter = 'blur(10px)';
                menu.style.border = '2px solid var(--primary-color)';
                
                menu.innerHTML = `
                    <div class="context-item" data-action="shuffle">üîÑ Shuffle</div>
                    <div class="context-item" data-action="draw">‚ú® Draw</div>
                    <div class="context-item" data-action="ai">ü§ñ AI Reading</div>
                    <div class="context-item" data-action="voice">üé§ Voice</div>
                `;
                
                document.body.appendChild(menu);
                
                // Add event listeners
                menu.querySelectorAll('.context-item').forEach(item => {
                    item.style.padding = '8px 12px';
                    item.style.cursor = 'pointer';
                    item.style.borderRadius = '5px';
                    item.style.margin = '2px 0';
                    item.style.transition = 'background 0.3s ease';
                    
                    item.addEventListener('mouseenter', () => {
                        item.style.background = 'var(--primary-color)';
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'transparent';
                    });
                    
                    item.addEventListener('click', () => {
                        const action = item.dataset.action;
                        this.executeContextAction(action);
                        document.body.removeChild(menu);
                    });
                });
                
                // Remove menu on outside click
                setTimeout(() => {
                    document.addEventListener('click', () => {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    }, { once: true });
                }, 100);
            }

            executeContextAction(action) {
                switch (action) {
                    case 'shuffle':
                        this.shuffleDeck();
                        break;
                    case 'draw':
                        this.drawCards();
                        break;
                    case 'ai':
                        this.generateAIReading(this.selectedCards);
                        break;
                    case 'voice':
                        this.startVoiceRecognition();
                        break;
                }
            }

            // Enhanced card reveal with AI
            async revealCard(x, y) {
                const card = this.findCardAt(x, y);
                if (card && !card.classList.contains('flipped')) {
                    card.classList.add('flipped');
                    
                    // Get card data
                    const cardData = this.currentDeck[parseInt(card.dataset.index)];
                    
                    // Generate AI prediction
                    if (this.aiEnabled) {
                        const accuracy = await this.predictReadingAccuracy([cardData]);
                        this.showNotification(`AI Prediction: ${Math.round(accuracy * 100)}% accuracy`, 'ai');
                    }
                    
                    // Create particles
                    const rect = card.getBoundingClientRect();
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            this.createParticle(rect.left + rect.width / 2, rect.top + rect.height / 2, 'reveal');
                        }, i * 50);
                    }
                    
                    // Play sound
                    this.playCardFlip();
                }
            }

            findCardAt(x, y) {
                const cards = document.querySelectorAll('.card');
                for (let card of cards) {
                    const rect = card.getBoundingClientRect();
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        return card;
                    }
                }
                return null;
            }

            // Enhanced sharing with AI insights
            async shareCurrentReading() {
                if (!this.selectedCards.length) {
                    this.showNotification('No reading to share', 'warning');
                    return;
                }
                
                const reading = {
                    cards: this.selectedCards.map(c => c.data),
                    interpretation: this.messageText.textContent,
                    environment: this.currentEnvironment,
                    timestamp: new Date().toISOString(),
                    aiInsights: this.aiEnabled ? this.aiInsights : null
                };
                
                await this.shareReading(reading);
                
                // Save to cloud if enabled
                if (this.communityEnabled) {
                    await this.saveToCloud(reading);
                }
            }

            // Enhanced custom cursor
            setupCustomCursor() {
                this.mousePos = { x: 0, y: 0 };
                this.cursorTrail = [];
                this.maxTrailLength = 20;
                
                document.addEventListener('mousemove', (e) => {
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                    
                    // Update cursor position
                    this.customCursor.style.left = e.clientX + 'px';
                    this.customCursor.style.top = e.clientY + 'px';
                    
                    // Update lighting
                    this.updateAmbientLighting(this.environments[this.currentEnvironment].ambientColor);
                    
                    // Add to trail
                    this.cursorTrail.push({ x: e.clientX, y: e.clientY, time: Date.now() });
                    if (this.cursorTrail.length > this.maxTrailLength) {
                        this.cursorTrail.shift();
                    }
                    
                    // Create trail particles occasionally
                    if (Math.random() < 0.3) {
                        this.createParticle(e.clientX, e.clientY, 'cursor');
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    this.customCursor.classList.add('active');
                });
                
                document.addEventListener('mouseup', () => {
                    this.customCursor.classList.remove('active');
                });
                
                // Hide cursor when leaving window
                document.addEventListener('mouseleave', () => {
                    this.customCursor.style.opacity = '0';
                });
                
                document.addEventListener('mouseenter', () => {
                    this.customCursor.style.opacity = '1';
                });
            }

            // Enhanced notification system
            showNotification(message, type = 'info') {
                const container = document.getElementById('notification-container');
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                // Add icon based on type
                const icons = {
                    success: '‚úÖ',
                    warning: '‚ö†Ô∏è',
                    error: '‚ùå',
                    info: '‚ÑπÔ∏è',
                    ai: 'ü§ñ'
                };
                
                notification.innerHTML = `
                    <span class="notification-icon">${icons[type] || icons.info}</span>
                    <span class="notification-text">${message}</span>
                    <button class="notification-close" onclick="this.parentElement.remove()">√ó</button>
                `;
                
                container.appendChild(notification);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.style.animation = 'notificationSlide 0.5s ease-out reverse';
                        setTimeout(() => notification.remove(), 500);
                    }
                }, 5000);
                
                // Create notification particles
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            window.innerWidth - 200 + Math.random() * 100,
                            50 + Math.random() * 50,
                            'notification'
                        );
                    }, i * 100);
                }
            }

            // Enhanced initialization
            async init() {
                this.showLoading();
                
                // Initialize all systems
                await this.delay(1000);
                this.createGlitterBackground();
                this.setupAmbientEffects();
                this.generateProceduralMusic();
                
                // Start animation loops
                this.animate();
                this.animateGlitter();
                this.animateShine();
                
                // Initial shuffle
                await this.shuffleDeck();
                
                this.hideLoading();
                
                // Welcome message
                this.showNotification('Welcome to Ultimate Mystical Tarot! üîÆ', 'success');
                
                // Voice introduction
                if (this.voiceEnabled) {
                    setTimeout(() => {
                        this.speakResponse("Welcome to your mystical tarot experience. Say shuffle to begin.");
                    }, 2000);
                }
            }

            // Enhanced animation loop with performance monitoring
            animate() {
                this.updatePerformanceMetrics();
                
                // Clear canvases
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.trailCtx.clearRect(0, 0, this.trailCanvas.width, this.trailCanvas.height);
                
                // Apply force fields
                this.applyForceFields();
                
                // Update and render particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    // Update particle
                    p.x += p.vx * this.animationSpeed;
                    p.y += p.vy * this.animationSpeed;
                    p.life -= this.animationSpeed;
                    p.rotation += p.rotationSpeed * this.animationSpeed;
                    
                    // Boundary checks
                    if (p.x < 0 || p.x > this.canvas.width || p.y < 0 || p.y > this.canvas.height) {
                        p.life = 0;
                    }
                    
                    // Render particle
                    if (p.life > 0) {
                        const alpha = p.life / p.maxLife;
                        
                        this.ctx.save();
                        this.ctx.translate(p.x, p.y);
                        this.ctx.rotate(p.rotation);
                        this.ctx.globalAlpha = alpha;
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = p.color;
                        this.ctx.fillStyle = p.color;
                        this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                        this.ctx.restore();
                    } else {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Render cursor trail
                this.renderCursorTrail();
                
                // Limit particle count for performance
                if (this.particles.length > this.maxParticles) {
                    this.particles.splice(0, this.particles.length - this.maxParticles);
                }
                
                requestAnimationFrame(() => this.animate());
            }

            renderCursorTrail() {
                if (this.cursorTrail.length < 2) return;
                
                this.trailCtx.strokeStyle = this.environments[this.currentEnvironment].particles;
                this.trailCtx.lineWidth = 3;
                this.trailCtx.lineCap = 'round';
                this.trailCtx.shadowBlur = 10;
                this.trailCtx.shadowColor = this.environments[this.currentEnvironment].particles;
                
                this.trailCtx.beginPath();
                this.trailCtx.moveTo(this.cursorTrail[0].x, this.cursorTrail[0].y);
                
                for (let i = 1; i < this.cursorTrail.length; i++) {
                    const point = this.cursorTrail[i];
                    const age = Date.now() - point.time;
                    const alpha = Math.max(0, 1 - age / 2000);
                    
                    this.trailCtx.globalAlpha = alpha;
                    this.trailCtx.lineTo(point.x, point.y);
                }
                
                this.trailCtx.stroke();
                this.trailCtx.globalAlpha = 1;
                
                // Clean up old trail points
                this.cursorTrail = this.cursorTrail.filter(point => Date.now() - point.time < 2000);
            }

            // Original methods with enhancements
            initializeData() {
                this.availableCards = [
                    { 
                        symbol: "‚≠ê", 
                        title: "The Star", 
                        description: "Hope, inspiration, and spiritual guidance",
                        fortune: "A period of hope and healing approaches. Trust in the universe's plan for you.",
                        rarity: "major",
                        element: "Air",
                        numerology: 17
                    },
                    { 
                        symbol: "üåô", 
                        title: "The Moon", 
                        description: "Intuition, mystery, and subconscious realms",
                        fortune: "Listen to your inner voice. Not everything is as it seems.",
                        rarity: "major",
                        element: "Water",
                        numerology: 18
                    },
                    // ... Continue with all 78 cards
                ];
            }

            initializeState() {
                this.currentDeck = [];
                this.selectedCards = [];
                this.isShuffling = false;
                this.isRevealed = false;
                this.savedFortunes = JSON.parse(localStorage.getItem('mysticalFortunes') || '[]');
                this.currentSpread = 'three-card';
                this.particleIntensity = 1;
                this.animationSpeed = 1;
                this.maxParticles = 300;
                this.particles = [];
                this.glitterParticles = [];
                this.shineParticles = [];
                
                this.spreadTypes = {
                    'three-card': {
                        name: 'Three Card Spread',
                        positions: [
                            { x: -120, y: 0, rotation: -10, name: 'Past' },
                            { x: 0, y: 0, rotation: 0, name: 'Present' },
                            { x: 120, y: 0, rotation: 10, name: 'Future' }
                        ]
                    },
                    'five-card': {
                        name: 'Five Card Cross',
                        positions: [
                            { x: 0, y: -80, rotation: 0, name: 'Spirit' },
                            { x: -80, y: 0, rotation: -15, name: 'Challenge' },
                            { x: 0, y: 0, rotation: 0, name: 'Focus' },
                            { x: 80, y: 0, rotation: 15, name: 'Action' },
                            { x: 0, y: 80, rotation: 0, name: 'Outcome' }
                        ]
                    },
                    'celtic-cross': {
                        name: 'Celtic Cross',
                        positions: [
                            { x: 0, y: 0, rotation: 0, name: 'Present' },
                            { x: 0, y: 0, rotation: 90, name: 'Challenge' },
                            { x: 0, y: -120, rotation: 0, name: 'Distant Past' },
                            { x: 0, y: 120, rotation: 0, name: 'Possible Future' },
                            { x: -120, y: 0, rotation: 0, name: 'Recent Past' },
                            { x: 120, y: 0, rotation: 0, name: 'Near Future' },
                            { x: 200, y: 120, rotation: 0, name: 'Your Approach' },
                            { x: 200, y: 60, rotation: 0, name: 'External Influences' },
                            { x: 200, y: 0, rotation: 0, name: 'Hopes & Fears' },
                            { x: 200, y: -60, rotation: 0, name: 'Final Outcome' }
                        ]
                    }
                };
                
                this.particleColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            }

            // Continue with all other methods...
            setupCanvas() {
                const canvases = [this.bgCanvas, this.canvas, this.glitterCanvas, this.shineCanvas, this.trailCanvas];
                
                canvases.forEach(canvas => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
                
                // Setup background
                this.createStarryBackground();
                
                // Resize handler
                window.addEventListener('resize', () => {
                    canvases.forEach(canvas => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    });
                    this.createStarryBackground();
                });
            }

            createStarryBackground() {
                const ctx = this.bgCtx;
                ctx.fillStyle = 'var(--bg-color)';
                ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                
                // Create stars
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * this.bgCanvas.width;
                    const y = Math.random() * this.bgCanvas.height;
                    const size = Math.random() * 2;
                    const opacity = Math.random() * 0.8 + 0.2;
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Additional helper methods
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            showLoading() {
                this.loadingElement.style.display = 'block';
                this.loadingElement.classList.add('animate__animated', 'animate__fadeIn');
            }

            hideLoading() {
                this.loadingElement.classList.add('animate__animated', 'animate__fadeOut');
                setTimeout(() => {
                    this.loadingElement.style.display = 'none';
                    this.loadingElement.classList.remove('animate__animated', 'animate__fadeIn', 'animate__fadeOut');
                }, 500);
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Continue with all original methods like shuffleDeck, drawCards, etc.
            // ... (Include all the original methods from the previous implementation)
        }

        // Gesture Recognition Helper Class
        class GestureRecognizer {
            constructor() {
                this.gestures = new Map();
                this.threshold = 50;
                this.timeThreshold = 1000;
            }

            addGesture(name, callback) {
                this.gestures.set(name, callback);
            }

            recognizeGesture(startX, startY, endX, endY, duration) {
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance < this.threshold) {
                    if (duration > this.timeThreshold) {
                        return 'long-press';
                    }
                    return 'tap';
                }
                
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                if (Math.abs(angle) < 45) return 'swipe-right';
                if (Math.abs(angle - 180) < 45) return 'swipe-left';
                if (angle > 45 && angle < 135) return 'swipe-down';
                if (angle < -45 && angle > -135) return 'swipe-up';
                
                return 'unknown';
            }
        }

        // Initialize the enhanced application
        document.addEventListener('DOMContentLoaded', () => {
            new UltimateMysticalTarot();
        });

        // Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>
</body>
</html>
l:wght@400;600;900&family=Cormorant+Garamond:wght@300;400;600&family=Poiret+One:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js"></script>
    <style>
        :root {
            --bg-color: #0a0618;
            --primary-color: #9969ff;
            --secondary-color: #ff69a1;
            --tertiary-color: #69b4ff;
            --accent-color: #ffeb3b;
            --text-color: #ffffff;
            --card-back: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #1a1a2e 75%, #16213e 100%);
            --card-front: linear-gradient(135deg, #2b2f66, #1c1647, #3f2a5c);
            --card-hover: #764ba2;
            --glitter-color: rgba(255, 235, 59, 0.9);
            --shine-color: hsla(280, 95%, 85%, 0.8);
            --tarot-gold: #ffd700;
            --tarot-silver: #c0c0c0;
            --tarot-bronze: #cd7f32;
            --env-filter: hue-rotate(0deg) saturate(1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Cormorant Garamond", serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            cursor: none;
            filter: var(--env-filter);
            transition: filter 2s ease;
        }

        /* Environment Filters */
        .env-moonlit { --env-filter: hue-rotate(10deg) saturate(1.2) brightness(0.9); }
        .env-forest { --env-filter: hue-rotate(80deg) saturate(1.5) brightness(0.8); }
        .env-cosmic { --env-filter: hue-rotate(250deg) saturate(1.8) brightness(1.1); }
        .env-temple { --env-filter: hue-rotate(30deg) saturate(1.3) brightness(1.2); }

        /* Custom Cursor Enhancement */
        .custom-cursor {
            width: 50px;
            height: 50px;
            border: 3px solid var(--shine-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(8px);
        }

        .custom-cursor.active {
            transform: scale(2.5);
            border-color: var(--accent-color);
            box-shadow: 0 0 50px var(--accent-color), inset 0 0 20px var(--accent-color);
        }

        .custom-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorPulse 2s ease-in-out infinite;
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 1px solid var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorRing 3s ease-in-out infinite;
        }

        @keyframes cursorPulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.8); }
        }

        @keyframes cursorRing {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Enhanced Environment Controls */
        .environment-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .env-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .env-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .env-btn.active {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
            animation: envActive 2s ease-in-out infinite;
        }

        @keyframes envActive {
            0%, 100% { box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 10px 40px var(--tarot-gold); }
        }

        /* Advanced Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid var(--shine-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-label {
            font-family: "Cinzel", serif;
            font-size: 0.9rem;
            color: var(--tarot-gold);
        }

        .control-slider {
            width: 200px;
            appearance: none;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            outline: none;
        }

        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--tarot-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--tarot-gold);
        }

        .control-toggle {
            width: 60px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-toggle.active {
            background: var(--primary-color);
        }

        .control-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .control-toggle.active::before {
            transform: translateX(30px);
        }

        /* Enhanced Card Preview Modal */
        .card-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
        }

        .card-preview-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .preview-content {
            width: 90%;
            max-width: 800px;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            padding: 3rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .preview-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--tarot-gold), transparent);
            animation: previewBorder 10s linear infinite;
            opacity: 0.3;
        }

        @keyframes previewBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .card-large {
            font-size: 6rem;
            margin-bottom: 1rem;
            position: relative;
            z-index: 2;
            animation: cardSymbolFloat 4s ease-in-out infinite;
        }

        @keyframes cardSymbolFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(5deg); }
            75% { transform: translateY(10px) rotate(-5deg); }
        }

        .preview-title {
            font-family: "Cinzel", serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-silver));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 2;
        }

        .meaning-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid var(--shine-color);
            position: relative;
            z-index: 2;
        }

        .meaning-title {
            font-family: "Cinzel", serif;
            font-size: 1.3rem;
            color: var(--tarot-gold);
            margin-bottom: 0.5rem;
        }

        .meaning-text {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }

        /* Voice Control Interface */
        .voice-control {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .voice-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .voice-btn.listening {
            animation: voiceListening 1s ease-in-out infinite;
        }

        .voice-btn.speaking {
            animation: voiceSpeaking 0.5s ease-in-out infinite;
        }

        @keyframes voiceListening {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
            50% { transform: scale(1.2); box-shadow: 0 20px 50px var(--tertiary-color); }
        }

        @keyframes voiceSpeaking {
            0%, 100% { background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color)); }
            50% { background: linear-gradient(45deg, var(--accent-color), var(--tertiary-color)); }
        }

        .voice-status {
            font-size: 0.8rem;
            color: var(--tarot-gold);
            text-align: center;
            opacity: 0.8;
        }

        /* AI Analysis Panel */
        .ai-analysis {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--primary-color);
            backdrop-filter: blur(15px);
            transform: translateY(100%);
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .ai-analysis.visible {
            transform: translateY(0);
        }

        .ai-title {
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            color: var(--tarot-gold);
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .ai-metric-label {
            color: var(--shine-color);
        }

        .ai-metric-value {
            color: var(--tarot-gold);
            font-weight: bold;
        }

        .ai-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 1s ease;
            border-radius: 4px;
        }

        /* Touch Gesture Indicators */
        .gesture-indicator {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 3px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 9000;
            transition: all 0.3s ease;
        }

        .gesture-indicator.active {
            opacity: 0.8;
            transform: scale(1.5);
        }

        .gesture-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: gestureRipple 1s ease-out infinite;
        }

        @keyframes gestureRipple {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Enhanced Lighting Effects */
        .lighting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                         rgba(255, 255, 255, 0.1) 0%, 
                         transparent 50%);
            transition: all 0.5s ease;
        }

        /* Performance Indicators */
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity:0;
}
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .perf-metric {
            display: inline-block;
            margin-right: 15px;
        }

        .perf-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Enhanced Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 15px;
            font-family: "Cinzel", serif;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            border: 2px solid var(--tarot-gold);
            backdrop-filter: blur(10px);
            animation: notificationSlide 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .notification::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: notificationShine 2s ease-in-out infinite;
        }

        @keyframes notificationShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .notification.success {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
        }

        .notification.warning {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .notification.error {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .notification.ai {
            background: linear-gradient(135deg, var(--tertiary-color), var(--primary-color));
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .environment-controls {
                flex-direction: row;
                top: auto;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .control-panel {
                width: 90%;
                max-width: 300px;
                right: 50%;
                transform: translateX(50%);
            }
            
            .ai-analysis {
                width: 90%;
                left: 50%;
                transform: translateX(-50%) translateY(100%);
            }
            
            .ai-analysis.visible {
                transform: translateX(-50%) translateY(0);
            }
            
            .voice-control {
                bottom: 120px;
            }
        }

        /* Canvas Enhancement */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #bg-canvas { z-index: 1; }
        #particle-canvas { z-index: 2; }
        #glitter-canvas { z-index: 3; }
        #shine-canvas { z-index: 4; }
        #lighting-canvas { z-index: 5; }
        #trail-canvas { z-index: 6; }

        /* Original styles continued... */
        .container {
            width: 100%;
            max-width: 1800px;
    <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Mystical Tarot - Advanced Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;900&family=Cormorant+Garamond:wght@300;400;600&family=Poiret+One:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js"></script>
    <style>
        :root {
            --bg-color: #0a0618;
            --primary-color: #9969ff;
            --secondary-color: #ff69a1;
            --tertiary-color: #69b4ff;
            --accent-color: #ffeb3b;
            --text-color: #ffffff;
            --card-back: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #1a1a2e 75%, #16213e 100%);
            --card-front: linear-gradient(135deg, #2b2f66, #1c1647, #3f2a5c);
            --card-hover: #764ba2;
            --glitter-color: rgba(255, 235, 59, 0.9);
            --shine-color: hsla(280, 95%, 85%, 0.8);
            --tarot-gold: #ffd700;
            --tarot-silver: #c0c0c0;
            --tarot-bronze: #cd7f32;
            --env-filter: hue-rotate(0deg) saturate(1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Cormorant Garamond", serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            cursor: none;
            filter: var(--env-filter);
            transition: filter 2s ease;
        }

        /* Environment Filters */
        .env-moonlit { --env-filter: hue-rotate(10deg) saturate(1.2) brightness(0.9); }
        .env-forest { --env-filter: hue-rotate(80deg) saturate(1.5) brightness(0.8); }
        .env-cosmic { --env-filter: hue-rotate(250deg) saturate(1.8) brightness(1.1); }
        .env-temple { --env-filter: hue-rotate(30deg) saturate(1.3) brightness(1.2); }

        /* Custom Cursor Enhancement */
        .custom-cursor {
            width: 50px;
            height: 50px;
            border: 3px solid var(--shine-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(8px);
        }

        .custom-cursor.active {
            transform: scale(2.5);
            border-color: var(--accent-color);
            box-shadow: 0 0 50px var(--accent-color), inset 0 0 20px var(--accent-color);
        }

        .custom-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorPulse 2s ease-in-out infinite;
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 1px solid var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorRing 3s ease-in-out infinite;
        }

        @keyframes cursorPulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.8); }
        }

        @keyframes cursorRing {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Enhanced Environment Controls */
        .environment-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .env-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .env-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .env-btn.active {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
            animation: envActive 2s ease-in-out infinite;
        }

        @keyframes envActive {
            0%, 100% { box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 10px 40px var(--tarot-gold); }
        }

        /* Advanced Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid var(--shine-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-label {
            font-family: "Cinzel", serif;
            font-size: 0.9rem;
            color: var(--tarot-gold);
        }

        .control-slider {
            width: 200px;
            appearance: none;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            outline: none;
        }

        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--tarot-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--tarot-gold);
        }

        .control-toggle {
            width: 60px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-toggle.active {
            background: var(--primary-color);
        }

        .control-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .control-toggle.active::before {
            transform: translateX(30px);
        }

        /* Enhanced Card Preview Modal */
        .card-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
        }

        .card-preview-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .preview-content {
            width: 90%;
            max-width: 800px;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            padding: 3rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .preview-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--tarot-gold), transparent);
            animation: previewBorder 10s linear infinite;
            opacity: 0.3;
        }

        @keyframes previewBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .card-large {
            font-size: 6rem;
            margin-bottom: 1rem;
            position: relative;
            z-index: 2;
            animation: cardSymbolFloat 4s ease-in-out infinite;
        }

        @keyframes cardSymbolFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(5deg); }
            75% { transform: translateY(10px) rotate(-5deg); }
        }

        .preview-title {
            font-family: "Cinzel", serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-silver));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 2;
        }

        .meaning-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid var(--shine-color);
            position: relative;
            z-index: 2;
        }

        .meaning-title {
            font-family: "Cinzel", serif;
            font-size: 1.3rem;
            color: var(--tarot-gold);
            margin-bottom: 0.5rem;
        }

        .meaning-text {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }

        /* Voice Control Interface */
        .voice-control {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .voice-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .voice-btn.listening {
            animation: voiceListening 1s ease-in-out infinite;
        }

        .voice-btn.speaking {
            animation: voiceSpeaking 0.5s ease-in-out infinite;
        }

        @keyframes voiceListening {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
            50% { transform: scale(1.2); box-shadow: 0 20px 50px var(--tertiary-color); }
        }

        @keyframes voiceSpeaking {
            0%, 100% { background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color)); }
            50% { background: linear-gradient(45deg, var(--accent-color), var(--tertiary-color)); }
        }

        .voice-status {
            font-size: 0.8rem;
            color: var(--tarot-gold);
            text-align: center;
            opacity: 0.8;
        }

        /* AI Analysis Panel */
        .ai-analysis {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--primary-color);
            backdrop-filter: blur(15px);
            transform: translateY(100%);
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .ai-analysis.visible {
            transform: translateY(0);
        }

        .ai-title {
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            color: var(--tarot-gold);
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .ai-metric-label {
            color: var(--shine-color);
        }

        .ai-metric-value {
            color: var(--tarot-gold);
            font-weight: bold;
        }

        .ai-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 1s ease;
            border-radius: 4px;
        }

        /* Touch Gesture Indicators */
        .gesture-indicator {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 3px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 9000;
            transition: all 0.3s ease;
        }

        .gesture-indicator.active {
            opacity: 0.8;
            transform: scale(1.5);
        }

        .gesture-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: gestureRipple 1s ease-out infinite;
        }

        @keyframes gestureRipple {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Enhanced Lighting Effects */
        .lighting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                         rgba(255, 255, 255, 0.1) 0%, 
                         transparent 50%);
            transition: all 0.5s ease;
        }

        /* Performance Indicators */
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity:0;
}
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .perf-metric {
            display: inline-block;
            margin-right: 15px;
        }

        .perf-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Enhanced Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 15px;
            font-family: "Cinzel", serif;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            border: 2px solid var(--tarot-gold);
            backdrop-filter: blur(10px);
            animation: notificationSlide 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .notification::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: notificationShine 2s ease-in-out infinite;
        }

        @keyframes notificationShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .notification.success {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
        }

        .notification.warning {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .notification.error {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .notification.ai {
            background: linear-gradient(135deg, var(--tertiary-color), var(--primary-color));
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .environment-controls {
                flex-direction: row;
                top: auto;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .control-panel {
                width: 90%;
                max-width: 300px;
                right: 50%;
                transform: translateX(50%);
            }
            
            .ai-analysis {
                width: 90%;
                left: 50%;
                transform: translateX(-50%) translateY(100%);
            }
            
            .ai-analysis.visible {
                transform: translateX(-50%) translateY(0);
            }
            
            .voice-control {
                bottom: 120px;
            }
        }

        /* Canvas Enhancement */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #bg-canvas { z-index: 1; }
        #particle-canvas { z-index: 2; }
        #glitter-canvas { z-index: 3; }
        #shine-canvas { z-index: 4; }
        #lighting-canvas { z-index: 5; }
        #trail-canvas { z-index: 6; }

        /* Original styles continued... */
        .container {
            width: 100%;
            max-width: 1800px;
     <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Mystical Tarot - Advanced Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;900&family=Cormorant+Garamond:wght@300;400;600&family=Poiret+One:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js"></script>
    <style>
        :root {
            --bg-color: #0a0618;
            --primary-color: #9969ff;
            --secondary-color: #ff69a1;
            --tertiary-color: #69b4ff;
            --accent-color: #ffeb3b;
            --text-color: #ffffff;
            --card-back: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #1a1a2e 75%, #16213e 100%);
            --card-front: linear-gradient(135deg, #2b2f66, #1c1647, #3f2a5c);
            --card-hover: #764ba2;
            --glitter-color: rgba(255, 235, 59, 0.9);
            --shine-color: hsla(280, 95%, 85%, 0.8);
            --tarot-gold: #ffd700;
            --tarot-silver: #c0c0c0;
            --tarot-bronze: #cd7f32;
            --env-filter: hue-rotate(0deg) saturate(1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Cormorant Garamond", serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            cursor: none;
            filter: var(--env-filter);
            transition: filter 2s ease;
        }

        /* Environment Filters */
        .env-moonlit { --env-filter: hue-rotate(10deg) saturate(1.2) brightness(0.9); }
        .env-forest { --env-filter: hue-rotate(80deg) saturate(1.5) brightness(0.8); }
        .env-cosmic { --env-filter: hue-rotate(250deg) saturate(1.8) brightness(1.1); }
        .env-temple { --env-filter: hue-rotate(30deg) saturate(1.3) brightness(1.2); }

        /* Custom Cursor Enhancement */
        .custom-cursor {
            width: 50px;
            height: 50px;
            border: 3px solid var(--shine-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(8px);
        }

        .custom-cursor.active {
            transform: scale(2.5);
            border-color: var(--accent-color);
            box-shadow: 0 0 50px var(--accent-color), inset 0 0 20px var(--accent-color);
        }

        .custom-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorPulse 2s ease-in-out infinite;
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 1px solid var(--shine-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: cursorRing 3s ease-in-out infinite;
        }

        @keyframes cursorPulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.8); }
        }

        @keyframes cursorRing {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Enhanced Environment Controls */
        .environment-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .env-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .env-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .env-btn.active {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
            animation: envActive 2s ease-in-out infinite;
        }

        @keyframes envActive {
            0%, 100% { box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 10px 40px var(--tarot-gold); }
        }

        /* Advanced Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid var(--shine-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-label {
            font-family: "Cinzel", serif;
            font-size: 0.9rem;
            color: var(--tarot-gold);
        }

        .control-slider {
            width: 200px;
            appearance: none;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            outline: none;
        }

        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--tarot-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--tarot-gold);
        }

        .control-toggle {
            width: 60px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-toggle.active {
            background: var(--primary-color);
        }

        .control-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .control-toggle.active::before {
            transform: translateX(30px);
        }

        /* Enhanced Card Preview Modal */
        .card-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
        }

        .card-preview-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .preview-content {
            width: 90%;
            max-width: 800px;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            padding: 3rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .preview-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--tarot-gold), transparent);
            animation: previewBorder 10s linear infinite;
            opacity: 0.3;
        }

        @keyframes previewBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .card-large {
            font-size: 6rem;
            margin-bottom: 1rem;
            position: relative;
            z-index: 2;
            animation: cardSymbolFloat 4s ease-in-out infinite;
        }

        @keyframes cardSymbolFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(5deg); }
            75% { transform: translateY(10px) rotate(-5deg); }
        }

        .preview-title {
            font-family: "Cinzel", serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-silver));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 2;
        }

        .meaning-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid var(--shine-color);
            position: relative;
            z-index: 2;
        }

        .meaning-title {
            font-family: "Cinzel", serif;
            font-size: 1.3rem;
            color: var(--tarot-gold);
            margin-bottom: 0.5rem;
        }

        .meaning-text {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }

        /* Voice Control Interface */
        .voice-control {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .voice-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .voice-btn.listening {
            animation: voiceListening 1s ease-in-out infinite;
        }

        .voice-btn.speaking {
            animation: voiceSpeaking 0.5s ease-in-out infinite;
        }

        @keyframes voiceListening {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
            50% { transform: scale(1.2); box-shadow: 0 20px 50px var(--tertiary-color); }
        }

        @keyframes voiceSpeaking {
            0%, 100% { background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color)); }
            50% { background: linear-gradient(45deg, var(--accent-color), var(--tertiary-color)); }
        }

        .voice-status {
            font-size: 0.8rem;
            color: var(--tarot-gold);
            text-align: center;
            opacity: 0.8;
        }

        /* AI Analysis Panel */
        .ai-analysis {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid var(--primary-color);
            backdrop-filter: blur(15px);
            transform: translateY(100%);
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .ai-analysis.visible {
            transform: translateY(0);
        }

        .ai-title {
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            color: var(--tarot-gold);
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .ai-metric-label {
            color: var(--shine-color);
        }

        .ai-metric-value {
            color: var(--tarot-gold);
            font-weight: bold;
        }

        .ai-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: width 1s ease;
            border-radius: 4px;
        }

        /* Touch Gesture Indicators */
        .gesture-indicator {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 3px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 9000;
            transition: all 0.3s ease;
        }

        .gesture-indicator.active {
            opacity: 0.8;
            transform: scale(1.5);
        }

        .gesture-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: gestureRipple 1s ease-out infinite;
        }

        @keyframes gestureRipple {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }

        /* Enhanced Lighting Effects */
        .lighting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
            background: radial-gradient(circle at var(--light-x, 50%) var(--light-y, 50%), 
                         rgba(255, 255, 255, 0.1) 0%, 
                         transparent 50%);
            transition: all 0.5s ease;
        }

        /* Performance Indicators */
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity:0;
}
        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--tarot-gold);
            border: 1px solid var(--primary-color);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .perf-metric {
            display: inline-block;
            margin-right: 15px;
        }

        .perf-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Enhanced Notification System */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .notification {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 15px;
            font-family: "Cinzel", serif;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            border: 2px solid var(--tarot-gold);
            backdrop-filter: blur(10px);
            animation: notificationSlide 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .notification::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: notificationShine 2s ease-in-out infinite;
        }

        @keyframes notificationShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .notification.success {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
        }

        .notification.warning {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .notification.error {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }

        .notification.ai {
            background: linear-gradient(135deg, var(--tertiary-color), var(--primary-color));
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .environment-controls {
                flex-direction: row;
                top: auto;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .control-panel {
                width: 90%;
                max-width: 300px;
                right: 50%;
                transform: translateX(50%);
            }
            
            .ai-analysis {
                width: 90%;
                left: 50%;
                transform: translateX(-50%) translateY(100%);
            }
            
            .ai-analysis.visible {
                transform: translateX(-50%) translateY(0);
            }
            
            .voice-control {
                bottom: 120px;
            }
        }

        /* Canvas Enhancement */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #bg-canvas { z-index: 1; }
        #particle-canvas { z-index: 2; }
        #glitter-canvas { z-index: 3; }
        #shine-canvas { z-index: 4; }
        #lighting-canvas { z-index: 5; }
        #trail-canvas { z-index: 6; }

        /* Original styles continued... */
        .container {
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 10;
        }

        /* Enhanced Header */
        header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
            z-index: 11;
        }

        .magical-title {
            font-family: "Cinzel", serif;
            font-size: 5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--tertiary-color), var(--accent-color));
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease infinite, titleFloat 6s ease-in-out infinite;
            text-shadow: 0 0 50px rgba(153, 105, 255, 0.8);
            position: relative;
            filter: drop-shadow(0 0 30px var(--shine-color));
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes titleFloat {
            0%, 100% { 
                transform: translateY(0px) scale(1); 
                filter: brightness(1) drop-shadow(0 0 30px var(--shine-color)); 
            }
            50% { 
                transform: translateY(-10px) scale(1.02); 
                filter: brightness(1.2) drop-shadow(0 0 50px var(--shine-color)); 
            }
        }

        .subtitle {
            font-size: 1.6rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto 2rem;
            animation: subtitleGlow 4s ease-in-out infinite;
            text-shadow: 0 0 15px var(--shine-color);
        }

        @keyframes subtitleGlow {
            0%, 100% { 
                opacity: 0.8; 
                text-shadow: 0 0 15px var(--shine-color); 
            }
            50% { 
                opacity: 1; 
                text-shadow: 0 0 25px var(--shine-color); 
            }
        }

        /* Enhanced Controls */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 3rem;
            flex-wrap: wrap;
            z-index: 11;
            position: relative;
        }

        .mystical-btn {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 1.5rem 3rem;
            font-family: "Cinzel", serif;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(153, 105, 255, 0.4);
            position: relative;
            overflow: hidden;
            transform: perspective(1000px) rotateX(0deg);
        }

        .mystical-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, var(--shine-color), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
            opacity: 0;
        }

        .mystical-btn:hover {
            transform: perspective(1000px) rotateX(10deg) translateY(-8px) scale(1.05);
            box-shadow: 0 20px 40px rgba(153, 105, 255, 0.8);
            filter: drop-shadow(0 0 20px var(--shine-color));
        }

        .mystical-btn:hover::before {
            animation: shimmer 1s ease-in-out;
        }

        .mystical-btn:active {
            transform: perspective(1000px) rotateX(5deg) translateY(-4px) scale(1.02);
        }

        .mystical-btn.shuffle {
            background: linear-gradient(45deg, var(--tertiary-color), var(--accent-color));
        }

        .mystical-btn.tarot {
            background: linear-gradient(45deg, var(--tarot-gold), var(--tarot-bronze));
        }

        @keyframes shimmer {
            0% { transform: translateX(-200%) translateY(-200%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(200%) translateY(200%) rotate(45deg); opacity: 0; }
        }

        /* Enhanced Card Styles */
        .card-table {
            perspective: 2000px;
            margin-bottom: 3rem;
            min-height: 600px;
            z-index: 11;
            position: relative;
        }

        .cards-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            max-width: 1400px;
            margin: 0 auto;
            padding: 3rem 2rem;
            position: relative;
        }

        .card {
            width: 140px;
            height: 240px;
            position: relative;
            transform-style: preserve-3d;
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            filter: brightness(0.9);
            border-radius: 20px;
        }

        .card:hover {
            filter: brightness(1.4) drop-shadow(0 0 30px var(--shine-color));
            transform: translateY(-30px) rotateY(15deg) rotateX(5deg) scale(1.1);
        }

        .card.selected {
            transform: scale(1.3) translateY(-50px) rotateY(10deg);
            z-index: 100;
            filter: drop-shadow(0 0 50px var(--shine-color)) brightness(1.5);
            animation: selectedGlow 2s ease-in-out infinite;
        }

        @keyframes selectedGlow {
            0%, 100% { 
                box-shadow: 0 0 30px var(--shine-color); 
            }
            50% { 
                box-shadow: 0 0 60px var(--shine-color); 
            }
        }

        .card-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            border: 2px solid var(--shine-color);
        }

        .card-back {
            background: var(--card-back);
            position: relative;
        }

        .card-front {
            background: var(--card-front);
            transform: rotateY(180deg);
            padding: 1.5rem;
            text-align: center;
            border: 2px solid var(--tarot-gold);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        /* Message Container */
        .message-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.8s ease;
            z-index: 1000;
        }

        .message-container.visible {
            opacity: 1;
            pointer-events: all;
        }

        .message-card {
            width: 90%;
            max-width: 800px;
            background: rgba(15, 10, 30, 0.98);
            backdrop-filter: blur(25px);
            padding: 4rem;
            border-radius: 30px;
            border: 3px solid var(--tarot-gold);
            text-align: center;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.8);
            transform: translateY(100px) scale(0.8);
            opacity: 0;
            transition: all 1.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .message-container.visible .message-card {
            transform: translateY(0) scale(1);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="custom-cursor"></div>
    <div class="glitter-bg"></div>
    <div class="lighting-overlay"></div>
    <div class="gesture-indicator"></div>
    
    <!-- Enhanced Canvas System -->
    <canvas id="bg-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <canvas id="glitter-canvas"></canvas>
    <canvas id="shine-canvas"></canvas>
    <canvas id="lighting-canvas"></canvas>
    <canvas id="trail-canvas"></canvas>
    
    <!-- Environment Controls -->
    <div class="environment-controls">
        <button class="env-btn active" data-env="moonlit" title="Moonlit">üåô</button>
        <button class="env-btn" data-env="forest" title="Forest">üå≤</button>
        <button class="env-btn" data-env="cosmic" title="Cosmic">üåå</button>
        <button class="env-btn" data-env="temple" title="Temple">üèõÔ∏è</button>
    </div>
    
    <!-- Advanced Control Panel -->
    <div class="control-panel">
        <div class="control-group">
            <label class="control-label">Particle Intensity</label>
            <input type="range" class="control-slider" id="particle-intensity" min="0.1" max="2" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label class="control-label">Animation Speed</label>
            <input type="range" class="control-slider" id="animation-speed" min="0.5" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label class="control-label">AI Analysis</label>
            <div class="control-toggle" id="ai-toggle"></div>
        </div>
        <div class="control-group">
            <label class="control-label">Voice Control</label>
            <div class="control-toggle" id="voice-toggle"></div>
        </div>
        <div class="control-group">
            <label class="control-label">Performance Monitor</label>
            <div class="control-toggle" id="perf-toggle"></div>
        </div>
    </div>
    
    <!-- Voice Control Interface -->
    <div class="voice-control">
        <button class="voice-btn" id="voice-btn">üé§</button>
        <div class="voice-status" id="voice-status">Ready</div>
    </div>
    
    <!-- AI Analysis Panel -->
    <div class="ai-analysis" id="ai-analysis">
        <div class="ai-title">AI Insights</div>
        <div class="ai-metric">
            <span class="ai-metric-label">Reading Accuracy:</span>
            <span class="ai-metric-value" id="ai-accuracy">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-accuracy-bar"></div>
        </div>
        <div class="ai-metric">
            <span class="ai-metric-label">Elemental Balance:</span>
            <span class="ai-metric-value" id="ai-balance">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-balance-bar"></div>
        </div>
        <div class="ai-metric">
            <span class="ai-metric-label">Spiritual Resonance:</span>
            <span class="ai-metric-value" id="ai-resonance">--</span>
        </div>
        <div class="ai-progress">
            <div class="ai-progress-bar" id="ai-resonance-bar"></div>
        </div>
    </div>
    
    <!-- Performance Monitor -->
    <div class="performance-monitor" id="performance-monitor">
        <div class="perf-metric">
            FPS: <span class="perf-value" id="fps-counter">--</span>
        </div>
        <div class="perf-metric">
            Particles: <span class="perf-value" id="particle-count">--</span>
        </div>
        <div class="perf-metric">
            Memory: <span class="perf-value" id="memory-usage">--</span>
        </div>
    </div>
    
    <!-- Notification Container -->
    <div class="notification-container" id="notification-container"></div>
    
    <!-- Loading Animation -->
    <div class="loading-animation" id="loading">
        <div class="loading-spinner"></div>
    </div>
    
    <!-- Main Content -->
    <div class="container">
        <header class="animate__animated animate__fadeInDown">
            <h1 class="magical-title">Ultimate Mystical Tarot</h1>
            <p class="subtitle">AI-Enhanced Tarot Experience with Advanced Mystical Features</p>
        </header>

        <div class="controls animate__animated animate__fadeInUp animate__delay-1s">
            <button id="shuffle-btn" class="mystical-btn shuffle">
                <span>üîÑ Shuffle Deck</span>
            </button>
            <button id="draw-cards-btn" class="mystical-btn">
                <span>‚ú® Draw Cards</span>
            </button>
            <button id="tarot-spread-btn" class="mystical-btn tarot">
                <span>üîÆ Tarot Spread</span>
            </button>
            <button id="ai-reading-btn" class="mystical-btn">
                <span>ü§ñ AI Reading</span>
            </button>
        </div>

        <div class="spread-selector" id="spread-selector" style="display: none;">
            <button class="spread-btn active" data-spread="three-card">Three Card</button>
            <button class="spread-btn" data-spread="five-card">Five Card</button>
            <button class="spread-btn" data-spread="celtic-cross">Celtic Cross</button>
        </div>

        <div class="card-table animate__animated animate__fadeInUp animate__delay-2s">
            <div class="cards-container" id="cards-container">
                <!-- Cards will be generated by JavaScript -->
            </div>
        </div>

        <!-- Card Preview Modal -->
        <div class="card-preview-modal" id="card-preview-modal">
            <div class="preview-content">
                <div class="card-large" id="preview-symbol">üîÆ</div>
                <div class="preview-title" id="preview-title">Card Title</div>
                <div class="meaning-section">
                    <div class="meaning-title">Upright Meaning</div>
                    <div class="meaning-text" id="preview-upright">Upright meaning...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Reversed Meaning</div>
                    <div class="meaning-text" id="preview-reversed">Reversed meaning...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Astrological Connection</div>
                    <div class="meaning-text" id="preview-astrology">Astrological connection...</div>
                </div>
                <div class="meaning-section">
                    <div class="meaning-title">Historical Context</div>
                    <div class="meaning-text" id="preview-history">Historical context...</div>
                </div>
                <button class="mystical-btn" onclick="closeCardPreview()">Close</button>
            </div>
        </div>

        <!-- Message Container -->
        <div class="message-container" id="message-container">
            <div class="message-card">
                <div class="message-title" id="message-title">Your Fortune</div>
                <div class="message-text" id="message-text"></div>
                <div class="fortune-details" id="fortune-details"></div>
                <div class="message-actions">
                    <button id="reshuffle-btn" class="mystical-btn">
                        <span>üîÑ New Reading</span>
                    </button>
                    <button id="save-fortune-btn" class="mystical-btn shuffle">
                        <span>üíæ Save Fortune</span>
                    </button>
                    <button id="export-btn" class="mystical-btn tarot">
                        <span>üì§ Export</span>
                    </button>
                    <button id="share-btn" class="mystical-btn">
                        <span>üì± Share</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Ultimate Mystical Tarot Application with AI Enhancement
        class UltimateMysticalTarot {
            constructor() {
                this.initializeCanvases();
                this.initializeElements();
                this.initializeData();
                this.initializeState();
                this.initializeAI();
                this.initializeAudio();
                this.initializeVoice();
                this.initializeTouchGestures();
                this.initializeEnvironments();
                this.initializePerformanceMonitor();
                this.setupEventListeners();
                this.setupCustomCursor();
                this.setupDynamicLighting();
                this.init();
            }

            // 1. AI-Powered Readings
            initializeAI() {
                this.aiEnabled = false;
                this.aiInsights = {
                    accuracy: 0,
                    balance: 0,
                    resonance: 0
                };
                
                this.cardElements = {
                    'The Fool': 'Air',
                    'The Magician': 'Air',
                    'The High Priestess': 'Water',
                    'The Empress': 'Earth',
                    'The Emperor': 'Fire',
                    'The Hierophant': 'Earth',
                    'The Lovers': 'Air',
                    'The Chariot': 'Water',
                    'Strength': 'Fire',
                    'The Hermit': 'Earth',
                    'Wheel of Fortune': 'Fire',
                    'Justice': 'Air',
                    'The Hanged Man': 'Water',
                    'Death': 'Water',
                    'Temperance': 'Fire',
                    'The Devil': 'Earth',
                    'The Tower': 'Fire',
                    'The Star': 'Air',
                    'The Moon': 'Water',
                    'The Sun': 'Fire',
                    'Judgement': 'Fire',
                    'The World': 'Earth'
                };
                
                this.cardNumerology = {
                    'The Fool': 0,
                    'The Magician': 1,
                    'The High Priestess': 2,
                    'The Empress': 3,
                    'The Emperor': 4,
                    'The Hierophant': 5,
                    'The Lovers': 6,
                    'The Chariot': 7,
                    'Strength': 8,
                    'The Hermit': 9,
                    'Wheel of Fortune': 10,
                    'Justice': 11,
                    'The Hanged Man': 12,
                    'Death': 13,
                    'Temperance': 14,
                    'The Devil': 15,
                    'The Tower': 16,
                    'The Star': 17,
                    'The Moon': 18,
                    'The Sun': 19,
                    'Judgement': 20,
                    'The World': 21
                };
            }

            generateAIReading(selectedCards) {
                if (!this.aiEnabled) return null;
                
                const elements = selectedCards.map(card => this.cardElements[card.title] || 'Unknown');
                const numbers = selectedCards.map(card => this.cardNumerology[card.title] || 0);
                
                // Calculate elemental balance
                const elementCount = elements.reduce((acc, element) => {
                    acc[element] = (acc[element] || 0) + 1;
                    return acc;
                }, {});
                
                const balance = this.calculateElementalBalance(elementCount);
                
                // Calculate numerological significance
                const numerSum = numbers.reduce((a, b) => a + b, 0);
                const numerReduced = this.reduceNumber(numerSum);
                
                // Calculate spiritual resonance
                const majorArcana = selectedCards.filter(card => card.rarity === 'major').length;
                const resonance = (majorArcana / selectedCards.length) * 100;
                
                // Calculate reading accuracy based on card synergy
                const accuracy = this.calculateCardSynergy(selectedCards);
                
                this.aiInsights = {
                    accuracy: Math.round(accuracy),
                    balance: Math.round(balance),
                    resonance: Math.round(resonance),
                    elementalDistribution: elementCount,
                    numerologicalSignificance: numerReduced,
                    recommendations: this.generateRecommendations(balance, resonance, accuracy)
                };
                
                this.updateAIPanel();
                
                return {
                    insights: this.aiInsights,
                    enhancedReading: this.generateEnhancedReading(selectedCards, this.aiInsights)
                };
            }

            calculateElementalBalance(elementCount) {
                const total = Object.values(elementCount).reduce((a, b) => a + b, 0);
                const expected = total / 4; // Perfect balance
                const variance = Object.values(elementCount).reduce((acc, count) => {
                    return acc + Math.pow(count - expected, 2);
                }, 0);
                return Math.max(0, 100 - (variance / expected) * 25);
            }

            reduceNumber(num) {
                while (num > 9) {
                    num = num.toString().split('').reduce((a, b) => parseInt(a) + parseInt(b), 0);
                }
                return num;
            }

            calculateCardSynergy(cards) {
                let synergy = 50; // Base synergy
                
                // Check for complementary cards
                const elements = cards.map(card => this.cardElements[card.title]);
                const uniqueElements = [...new Set(elements)];
                
                if (uniqueElements.length === cards.length) {
                    synergy += 20; // Diverse elements
                } else if (uniqueElements.length === 1) {
                    synergy += 15; // Unified element
                }
                
                // Check for sequential numbers
                const numbers = cards.map(card => this.cardNumerology[card.title]).sort((a, b) => a - b);
                for (let i = 0; i < numbers.length - 1; i++) {
                    if (numbers[i + 1] - numbers[i] === 1) {
                        synergy += 10; // Sequential bonus
                    }
                }
                
                return Math.min(100, synergy);
            }

            generateRecommendations(balance, resonance, accuracy) {
                const recommendations = [];
                
                if (balance < 50) {
                    recommendations.push("Focus on balancing different aspects of your life");
                }
                if (resonance > 70) {
                    recommendations.push("Major life themes are prominent - pay attention to spiritual messages");
                }
                if (accuracy > 80) {
                    recommendations.push("The cards are in strong harmony - trust the guidance");
                }
                
                return recommendations;
            }

            generateEnhancedReading(cards, insights) {
                const baseReading = cards.map(card => card.fortune).join(' ');
                const enhancement = `\n\nAI Analysis: Your reading shows ${insights.accuracy}% accuracy with ${insights.balance}% elemental balance. The spiritual resonance is ${insights.resonance}%, indicating ${insights.resonance > 70 ? 'strong' : 'moderate'} spiritual significance.`;
                
                return baseReading + enhancement;
            }

            updateAIPanel() {
                if (!this.aiEnabled) return;
                
                document.getElementById('ai-accuracy').textContent = this.aiInsights.accuracy + '%';
                document.getElementById('ai-balance').textContent = this.aiInsights.balance + '%';
                document.getElementById('ai-resonance').textContent = this.aiInsights.resonance + '%';
                
                document.getElementById('ai-accuracy-bar').style.width = this.aiInsights.accuracy + '%';
                document.getElementById('ai-balance-bar').style.width = this.aiInsights.balance + '%';
                document.getElementById('ai-resonance-bar').style.width = this.aiInsights.resonance + '%';
                
                document.getElementById('ai-analysis').classList.add('visible');
            }

            // 2. Immersive Environments
            initializeEnvironments() {
                this.currentEnvironment = 'moonlit';
                this.environments = {
                    moonlit: {
                        particles: '#c0c0ff',
                        glitter: '#e6e6ff',
                        shine: '#ffffff',
                        filter: 'hue-rotate(10deg) saturate(1.2) brightness(0.9)',
                        ambientColor: 'rgba(192, 192, 255, 0.1)'
                    },
                    forest: {
                        particles: '#90EE90',
                        glitter: '#32CD32',
                        shine: '#ADFF2F',
                        filter: 'hue-rotate(80deg) saturate(1.5) brightness(0.8)',
                        ambientColor: 'rgba(144, 238, 144, 0.1)'
                    },
                    cosmic: {
                        particles: '#FF1493',
                        glitter: '#00BFFF',
                        shine: '#FFD700',
                        filter: 'hue-rotate(250deg) saturate(1.8) brightness(1.1)',
                        ambientColor: 'rgba(255, 20, 147, 0.1)'
                    },
                    temple: {
                        particles: '#FFD700',
                        glitter: '#FFA500',
                        shine: '#FFFF00',
                        filter: 'hue-rotate(30deg) saturate(1.3) brightness(1.2)',
                        ambientColor: 'rgba(255, 215, 0, 0.1)'
                    }
                };
            }

            switchEnvironment(envName) {
                this.currentEnvironment = envName;
                const env = this.environments[envName];
                
                // Update CSS variables
                document.documentElement.style.setProperty('--env-filter', env.filter);
                
                // Update particle colors
                this.updateParticleColors(env);
                
                // Update lighting
                this.updateAmbientLighting(env.ambientColor);
                
                // Update UI
                document.querySelectorAll('.env-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-env="${envName}"]`).classList.add('active');
                
                this.showNotification(`Environment changed to ${envName.charAt(0).toUpperCase() + envName.slice(1)}`, 'success');
            }

            updateParticleColors(env) {
                this.particleColors = [env.particles, env.glitter, env.shine];
                
                // Update existing particles
                this.particles.forEach(particle => {
                    particle.color = this.particleColors[Math.floor(Math.random() * this.particleColors.length)];
                });
                
                this.glitterParticles.forEach(particle => {
                    particle.color = env.glitter;
                });
                
                this.shineParticles.forEach(particle => {
                    particle.color = env.shine;
                });
            }

            updateAmbientLighting(color) {
                const lightingOverlay = document.querySelector('.lighting-overlay');
                const mouseX = (this.mousePos.x / window.innerWidth) * 100;
                const mouseY = (this.mousePos.y / window.innerHeight) * 100;
                
                lightingOverlay.style.background = `radial-gradient(circle at ${mouseX}% ${mouseY}%, ${color} 0%, transparent 50%)`;
            }

            // 3. Enhanced Card Interactions
            showCardPreview(card) {
                const modal = document.getElementById('card-preview-modal');
                const extendedCard = this.getExtendedCardData(card);
                
                document.getElementById('preview-symbol').textContent = card.symbol;
                document.getElementById('preview-title').textContent = card.title;
                document.getElementById('preview-upright').textContent = extendedCard.upright;
                document.getElementById('preview-reversed').textContent = extendedCard.reversed;
                document.getElementById('preview-astrology').textContent = extendedCard.astrology;
                document.getElementById('preview-history').textContent = extendedCard.history;
                
                modal.classList.add('visible');
                
                // Create preview particles
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'preview'
                        );
                    }, i * 100);
                }
            }

            getExtendedCardData(card) {
                const extended = {
                    upright: card.fortune,
                    reversed: this.getReversedMeaning(card.title),
                    astrology: this.getAstrologicalConnection(card.title),
                    history: this.getHistoricalContext(card.title)
                };
                
                return extended;
            }

            getReversedMeaning(cardTitle) {
                const reversedMeanings = {
                    'The Star': 'Self-doubt, lack of faith, pessimism, disconnection from higher purpose',
                    'The Moon': 'Overcoming fear, finding truth, released illusions, clarity emerging',
                    'The Sun': 'Temporary setbacks, lack of enthusiasm, delayed success, inner child healing needed',
                    'The Tower': 'Avoiding disaster, delaying the inevitable, internal transformation',
                    'The Magician': 'Manipulation, untapped potential, lack of willpower, scattered energy',
                    'The High Priestess': 'Hidden motives, superficial knowledge, ignoring intuition',
                    'The Empress': 'Neglecting self-care, creative blocks, lack of growth',
                    'The Emperor': 'Abuse of power, lack of control, avoiding responsibility',
                    'The Hierophant': 'Challenging tradition, freedom from conformity, personal beliefs',
                    'The Lovers': 'Relationship issues, misaligned values, inner conflict',
                    'Temperance': 'Imbalance, extremes, lack of moderation, rushed decisions',
                    'The Fool': 'Recklessness, holding back, fear of the unknown'
                };
                
                return reversedMeanings[cardTitle] || 'Reversed energy of this card suggests internal work needed';
            }

                        getHistoricalContext(cardTitle) {
                const historicalContext = {
                    'The Star': 'Ancient symbol of divine guidance, featured in Egyptian and Greek mythology as connection to celestial wisdom',
                    'The Moon': 'Represents the Triple Goddess in many traditions, symbolizing maiden, mother, and crone aspects',
                    'The Sun': 'Solar deities across cultures - Ra, Apollo, Helios - representing consciousness and enlightenment',
                    'The Tower': 'Tower of Babel archetype, representing hubris and divine intervention',
                    'The Magician': 'Hermetic tradition of "as above, so below" - mastery over elements and manifestation',
                    'The High Priestess': 'Temple mysteries of ancient Egypt and Greece, keeper of sacred knowledge',
                    'The Empress': 'Earth Mother archetype found in cultures worldwide - Demeter, Gaia, Pachamama',
                    'The Emperor': 'Divine kingship concept from ancient civilizations - pharaohs, caesars, mandates of heaven',
                    'The Hierophant': 'Spiritual teacher role in mystery schools and religious traditions',
                    'The Lovers': 'Sacred marriage concept in alchemy and mysticism, union of opposites',
                    'Temperance': 'Alchemical process of solve et coagula - dissolution and coagulation',
                    'The Fool': 'Holy fool tradition in many cultures, divine wisdom through innocence'
                };
                
                return historicalContext[cardTitle] || 'Rich symbolic history spanning multiple mystical traditions';
            }

            closeCardPreview() {
                document.getElementById('card-preview-modal').classList.remove('visible');
            }

            // 4. Advanced Particle Physics
            initializeAdvancedParticles() {
                this.particlePool = [];
                this.forceFields = [];
                this.attractors = [];
                this.magneticFields = [];
                
                // Create particle pool for performance
                for (let i = 0; i < 1000; i++) {
                    this.particlePool.push(this.createEmptyParticle());
                }
            }

            createEmptyParticle() {
                return {
                    x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0,
                    active: false, type: '', rotation: 0, rotationSpeed: 0,
                    alpha: 1, trail: [], mass: 1, charge: 0
                };
            }

            getParticleFromPool() {
                return this.particlePool.find(p => !p.active) || this.createEmptyParticle();
            }

            createMagneticField(x, y, strength, polarity = 1) {
                this.magneticFields.push({
                    x, y, strength, polarity,
                    affect: (particle) => {
                        const dx = x - particle.x;
                        const dy = y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            const force = (strength * polarity) / (distance * distance);
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            
                            particle.vx += forceX * particle.charge;
                            particle.vy += forceY * particle.charge;
                        }
                    }
                });
            }

            createParticleTrail(startX, startY, endX, endY, particleCount = 20) {
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    
                    setTimeout(() => {
                        const particle = this.getParticleFromPool();
                        this.initializeParticle(particle, x, y, 'trail');
                        particle.charge = Math.random() > 0.5 ? 1 : -1;
                    }, i * 50);
                }
            }

            applyForceFields() {
                this.particles.forEach(particle => {
                    this.magneticFields.forEach(field => {
                        field.affect(particle);
                    });
                    
                    // Apply physics
                    particle.vx *= 0.99; // Air resistance
                    particle.vy *= 0.99;
                    particle.vy += 0.05; // Gravity
                });
            }

            // 5. Dynamic Lighting System
            setupDynamicLighting() {
                this.lightingCanvas = document.getElementById('lighting-canvas');
                this.lightingCtx = this.lightingCanvas.getContext('2d');
                this.lights = [];
                this.shadows = [];
                this.ambientIntensity = 0.3;
                
                // Add initial lights
                this.addPointLight(window.innerWidth / 2, window.innerHeight / 2, '255, 255, 255', 0.5, 300);
                this.addPointLight(100, 100, '153, 105, 255', 0.3, 200);
                this.addPointLight(window.innerWidth - 100, 100, '255, 105, 153', 0.3, 200);
                
                this.animateLighting();
            }

            addPointLight(x, y, color, intensity, radius) {
                this.lights.push({
                    x, y, color, intensity, radius,
                    originalIntensity: intensity,
                    flicker: Math.random() * 0.1 + 0.9,
                    flickerSpeed: Math.random() * 0.01 + 0.005,
                    time: 0,
                    update: function() {
                        this.time += this.flickerSpeed;
                        this.flicker = Math.sin(this.time) * 0.1 + 0.9;
                        this.intensity = this.originalIntensity * this.flicker;
                    }
                });
            }

            animateLighting() {
                this.lightingCtx.clearRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                
                // Update mouse light position
                if (this.lights.length > 0) {
                    this.lights[0].x = this.mousePos.x;
                    this.lights[0].y = this.mousePos.y;
                }
                
                // Update all lights
                this.lights.forEach(light => light.update());
                
                // Render lighting
                this.renderLighting();
                
                requestAnimationFrame(() => this.animateLighting());
            }

            renderLighting() {
                // Create ambient darkness
                this.lightingCtx.globalCompositeOperation = 'source-over';
                this.lightingCtx.fillStyle = `rgba(0, 0, 0, ${1 - this.ambientIntensity})`;
                this.lightingCtx.fillRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                
                // Add light sources
                this.lightingCtx.globalCompositeOperation = 'screen';
                this.lights.forEach(light => {
                    const gradient = this.lightingCtx.createRadialGradient(
                        light.x, light.y, 0,
                        light.x, light.y, light.radius
                    );
                    gradient.addColorStop(0, `rgba(${light.color}, ${light.intensity})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    this.lightingCtx.fillStyle = gradient;
                    this.lightingCtx.fillRect(0, 0, this.lightingCanvas.width, this.lightingCanvas.height);
                });
            }

            // 6. Spatial Audio & Music
            initializeAudio() {
                this.audioEnabled = true;
                this.audioContext = null;
                this.spatialAudio = null;
                this.masterGain = null;
                this.convolver = null;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.spatialAudio = this.audioContext.createPanner();
                    this.convolver = this.audioContext.createConvolver();
                    
                    // Setup spatial audio
                    this.spatialAudio.panningModel = 'HRTF';
                    this.spatialAudio.distanceModel = 'inverse';
                    this.spatialAudio.refDistance = 1;
                    this.spatialAudio.maxDistance = 10000;
                    this.spatialAudio.rolloffFactor = 1;
                    
                    // Connect audio graph
                    this.masterGain.connect(this.spatialAudio);
                    this.spatialAudio.connect(this.convolver);
                    this.convolver.connect(this.audioContext.destination);
                    
                    this.masterGain.gain.value = 0.3;
                    
                    // Load reverb impulse
                    this.loadReverbImpulse();
                    
                } catch (error) {
                    console.warn("Enhanced audio not supported:", error);
                    this.audioEnabled = false;
                }
            }

            loadReverbImpulse() {
                // Create synthetic reverb impulse
                const length = this.audioContext.sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.convolver.buffer = impulse;
            }

            create3DAudio(x, y, z, frequency, duration) {
                if (!this.audioEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Position audio in 3D space
                this.spatialAudio.positionX.value = x;
                this.spatialAudio.positionY.value = y;
                this.spatialAudio.positionZ.value = z;
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            generateProceduralMusic() {
                const scales = {
                    mystical: [261.63, 293.66, 329.63, 392.00, 440.00, 493.88],
                    ethereal: [256, 288, 320, 384, 432, 480],
                    cosmic: [220, 247, 277, 311, 349, 392]
                };
                
                const scale = scales[this.currentEnvironment] || scales.mystical;
                
                // Play ambient arpeggios
                this.playArpeggio(scale, 3000);
                
                // Schedule next musical phrase
                setTimeout(() => this.generateProceduralMusic(), 8000 + Math.random() * 4000);
            }

            playArpeggio(scale, duration) {
                if (!this.audioEnabled) return;
                
                scale.forEach((frequency, index) => {
                    setTimeout(() => {
                        this.create3DAudio(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            Math.random() * 100 - 50,
                            frequency,
                            duration / scale.length
                        );
                    }, index * (duration / scale.length) * 0.8);
                });
            }

            // 7. Voice Integration
            initializeVoice() {
                this.voiceEnabled = false;
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.voiceStatus = 'Ready';
                
                if ('webkitSpeechRecognition' in window) {
                    this.recognition = new webkitSpeechRecognition();
                    this.setupVoiceRecognition();
                } else if ('SpeechRecognition' in window) {
                    this.recognition = new SpeechRecognition();
                    this.setupVoiceRecognition();
                } else {
                    console.warn("Speech recognition not supported");
                }
            }

            setupVoiceRecognition() {
                if (!this.recognition) return;
                
                this.recognition.continuous = false;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';
                
                this.recognition.onstart = () => {
                    this.voiceStatus = 'Listening...';
                    this.updateVoiceStatus();
                    document.getElementById('voice-btn').classList.add('listening');
                };
                
                this.recognition.onend = () => {
                    this.voiceStatus = 'Ready';
                    this.updateVoiceStatus();
                    document.getElementById('voice-btn').classList.remove('listening');
                };
                
                this.recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase();
                    this.processVoiceCommand(command);
                };
                
                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.voiceStatus = 'Error';
                    this.updateVoiceStatus();
                };
            }

            processVoiceCommand(command) {
                console.log('Voice command:', command);
                
                if (command.includes('shuffle')) {
                    this.shuffleDeck();
                    this.speakResponse("Shuffling the deck for you");
                } else if (command.includes('draw')) {
                    this.drawCards();
                    this.speakResponse("Drawing your cards");
                } else if (command.includes('reading')) {
                    this.generateAIReading(this.selectedCards);
                    this.speakResponse("Generating AI reading");
                } else if (command.includes('environment')) {
                    if (command.includes('forest')) {
                        this.switchEnvironment('forest');
                    } else if (command.includes('cosmic')) {
                        this.switchEnvironment('cosmic');
                    } else if (command.includes('temple')) {
                        this.switchEnvironment('temple');
                    } else {
                        this.switchEnvironment('moonlit');
                    }
                } else {
                    this.speakResponse("I didn't understand that command. Try saying shuffle, draw, or reading.");
                }
            }

            speakResponse(text) {
                if (!this.synthesis) return;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.8;
                utterance.pitch = 0.9;
                utterance.voice = this.findMysticalVoice();
                
                utterance.onstart = () => {
                    document.getElementById('voice-btn').classList.add('speaking');
                };
                
                utterance.onend = () => {
                    document.getElementById('voice-btn').classList.remove('speaking');
                };
                
                this.synthesis.speak(utterance);
            }

            findMysticalVoice() {
                const voices = this.synthesis.getVoices();
                return voices.find(voice => 
                    voice.name.includes('Female') || 
                    voice.name.includes('Samantha') ||
                    voice.name.includes('Serena')
                ) || voices[0];
            }

            updateVoiceStatus() {
                document.getElementById('voice-status').textContent = this.voiceStatus;
            }

            startVoiceRecognition() {
                if (!this.recognition || !this.voiceEnabled) return;
                
                try {
                    this.recognition.start();
                } catch (error) {
                    console.error('Voice recognition error:', error);
                }
            }

            // 8. Advanced Touch Interactions
            initializeTouchGestures() {
                this.gestureRecognizer = new GestureRecognizer();
                this.setupGestures();
            }

            setupGestures() {
                let startY = 0;
                let startX = 0;
                let startTime = 0;
                
                document.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                    startX = e.touches[0].clientX;
                    startTime = Date.now();
                    
                    this.showGestureIndicator(startX, startY);
                });
                
                document.addEventListener('touchmove', (e) => {
                    const currentY = e.touches[0].clientY;
                    const currentX = e.touches[0].clientX;
                    const deltaY = startY - currentY;
                    const deltaX = startX - currentX;
                    
                    if (Math.abs(deltaY) > 50 || Math.abs(deltaX) > 50) {
                        this.updateGestureIndicator(currentX, currentY);
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', (e) => {
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    const endY = e.changedTouches[0].clientY;
                    const endX = e.changedTouches[0].clientX;
                    const deltaY = startY - endY;
                    const deltaX = startX - endX;
                    
                    this.hideGestureIndicator();
                    
                    if (duration > 1000) {
                        this.handleLongPress(endX, endY);
                    } else if (Math.abs(deltaY) > 100) {
                        if (deltaY > 0) {
                            this.handleSwipeUp(endX, endY);
                        } else {
                            this.handleSwipeDown(endX, endY);
                        }
                    } else if (Math.abs(deltaX) > 100) {
                        if (deltaX > 0) {
                            this.handleSwipeLeft(endX, endY);
                        } else {
                            this.handleSwipeRight(endX, endY);
                        }
                    }
                });
            }

            showGestureIndicator(x, y) {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.style.left = (x - 50) + 'px';
                indicator.style.top = (y - 50) + 'px';
                indicator.classList.add('active');
            }

            updateGestureIndicator(x, y) {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.style.left = (x - 50) + 'px';
                indicator.style.top = (y - 50) + 'px';
            }

            hideGestureIndicator() {
                const indicator = document.querySelector('.gesture-indicator');
                indicator.classList.remove('active');
            }

            handleSwipeUp(x, y) {
                this.revealCard(x, y);
                this.addHapticFeedback('reveal');
            }

            handleSwipeDown(x, y) {
                this.shuffleDeck();
                this.addHapticFeedback('shuffle');
            }

            handleSwipeLeft(x, y) {
                this.previousEnvironment();
                this.addHapticFeedback('select');
            }

            handleSwipeRight(x, y) {
                this.nextEnvironment();
                this.addHapticFeedback('select');
            }

            handleLongPress(x, y) {
                this.showContextMenu(x, y);
                this.addHapticFeedback('menu');
            }

            addHapticFeedback(type) {
                if (!navigator.vibrate) return;
                
                const patterns = {
                    shuffle: [100, 50, 100, 50, 100],
                    flip: [200],
                    select: [50, 25, 50],
                    reveal: [300, 100, 300],
                    menu: [50, 50, 50]
                };
                
                navigator.vibrate(patterns[type] || [100]);
            }

            // 9. AI Accessibility
            initializeAccessibility() {
                this.screenReader = new ScreenReaderEnhancer();
                this.colorBlindness = new ColorBlindnessAdapter();
                this.motionSensitivity = new MotionAdapter();
                this.highContrast = false;
                this.reducedMotion = false;
            }

            describeCard(card) {
                const description = `${card.title}, symbolized by ${card.symbol}. ${card.description}. 
                    Upright meaning: ${card.fortune}. 
                    This card represents themes of ${card.symbolism || 'mystery and guidance'}.
                    Element: ${this.cardElements[card.title] || 'Universal'}.
                    Numerology: ${this.cardNumerology[card.title] || 'Variable'}.`;
                
                return description;
            }

            announceForScreenReader(text) {
                const announcement = document.createElement('div');
                announcement.setAttribute('aria-live', 'polite');
                announcement.setAttribute('aria-atomic', 'true');
                announcement.style.position = 'absolute';
                announcement.style.left = '-10000px';
                announcement.style.width = '1px';
                announcement.style.height = '1px';
                announcement.style.overflow = 'hidden';
                announcement.textContent = text;
                
                document.body.appendChild(announcement);
                
                setTimeout(() => {
                    document.body.removeChild(announcement);
                }, 1000);
            }

            toggleHighContrast() {
                this.highContrast = !this.highContrast;
                document.body.classList.toggle('high-contrast', this.highContrast);
            }

            toggleReducedMotion() {
                this.reducedMotion = !this.reducedMotion;
                document.body.classList.toggle('reduced-motion', this.reducedMotion);
                
                if (this.reducedMotion) {
                    this.animationSpeed = 0.3;
                } else {
                    this.animationSpeed = 1;
                }
            }

            // 10. Performance Optimization
            initializePerformanceMonitor() {
                this.performanceMonitor = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: performance.now(),
                    memoryUsage: 0,
                    particleCount: 0,
                    enabled: false
                };
                
                this.deviceCapabilities = this.detectDeviceCapabilities();
                this.optimizeForDevice();
            }

            detectDeviceCapabilities() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                let gpu = 'medium';
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        if (renderer.includes('Intel')) gpu = 'low';
                        if (renderer.includes('NVIDIA') || renderer.includes('AMD')) gpu = 'high';
                    }
                }
                
                return {
                    gpu: gpu,
                    memory: navigator.deviceMemory || 4,
                    hardwareConcurrency: navigator.hardwareConcurrency || 4,
                    connection: navigator.connection?.effectiveType || '4g'
                };
            }

            optimizeForDevice() {
                if (this.deviceCapabilities.gpu === 'low') {
                    this.maxParticles = 150;
                    this.animationQuality = 'low';
                } else if (this.deviceCapabilities.gpu === 'high') {
                    this.maxParticles = 500;
                    this.animationQuality = 'high';
                } else {
                    this.maxParticles = 300;
                    this.animationQuality = 'medium';
                }
                
                if (this.deviceCapabilities.memory < 4) {
                    this.maxParticles = Math.floor(this.maxParticles * 0.7);
                }
            }

            updatePerformanceMetrics() {
                if (!this.performanceMonitor.enabled) return;
                
                const now = performance.now();
                this.performanceMonitor.frameCount++;
                
                if (now - this.performanceMonitor.lastTime >= 1000) {
                    this.performanceMonitor.fps = this.performanceMonitor.frameCount;
                    this.performanceMonitor.frameCount = 0;
                    this.performanceMonitor.lastTime = now;
                    
                    if (performance.memory) {
                        this.performanceMonitor.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    }
                    
                    this.performanceMonitor.particleCount = this.particles.length + this.glitterParticles.length + this.shineParticles.length;
                    
                    this.updatePerformanceDisplay();
                }
            }

            updatePerformanceDisplay() {
                document.getElementById('fps-counter').textContent = this.performanceMonitor.fps;
                document.getElementById('particle-count').textContent = this.performanceMonitor.particleCount;
                document.getElementById('memory-usage').textContent = this.performanceMonitor.memoryUsage + ' MB';
                
                // Auto-optimize based on performance
                if (this.performanceMonitor.fps < 30 && this.maxParticles > 100) {
                    this.maxParticles = Math.floor(this.maxParticles * 0.9);
                    this.showNotification('Performance optimized', 'warning');
                }
            }

            // 11. Machine Learning Integration
            initializeMachineLearning() {
                this.mlEnabled = false;
                this.model = null;
                this.trainingData = [];
                this.predictions = [];
                
                // Initialize TensorFlow.js model
                this.buildModel();
            }

            async buildModel() {
                try {
                    this.model = tf.sequential({
                        layers: [
                            tf.layers.dense({
                                inputShape: [78], // 78 tarot cards
                                units: 128,
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({
                                units: 64,
                                activation: 'relu'
                            }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({
                                units: 32,
                                activation: 'relu'
                            }),
                            tf.layers.dense({
                                units: 1,
                                activation: 'sigmoid'
                            })
                        ]
                    });
                    
                    this.model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });
                    
                    this.mlEnabled = true;
                    console.log('ML model initialized');
                } catch (error) {
                    console.error('ML initialization failed:', error);
                }
            }

            async predictReadingAccuracy(cards, userFeedback = null) {
                if (!this.mlEnabled || !this.model) return 0.5;
                
                try {
                    const input = this.encodeCards(cards);
                    const prediction = await this.model.predict(input).data();
                    
                    if (userFeedback !== null) {
                        this.addTrainingData(input, userFeedback);
                    }
                    
                    return prediction[0];
                } catch (error) {
                    console.error('Prediction error:', error);
                    return 0.5;
                }
            }

            encodeCards(cards) {
                const encoded = new Array(78).fill(0);
                cards.forEach(card => {
                    const index = this.getCardIndex(card.title);
                    if (index >= 0) encoded[index] = 1;
                });
                return tf.tensor2d([encoded]);
            }

            getCardIndex(cardTitle) {
                const cardNames = Object.keys(this.cardNumerology);
                return cardNames.indexOf(cardTitle);
            }

            addTrainingData(input, feedback) {
                this.trainingData.push({
                    input: input,
                    output: feedback > 0.5 ? 1 : 0
                });
                
                // Retrain model periodically
                if (this.trainingData.length >= 10) {
                    this.retrainModel();
                }
            }

            async retrainModel() {
                if (this.trainingData.length < 5) return;
                
                try {
                    const inputs = tf.stack(this.trainingData.map(d => d.input));
                    const outputs = tf.tensor2d(this.trainingData.map(d => [d.output]));
                    
                    await this.model.fit(inputs, outputs, {
                        epochs: 5,
                        batchSize: 5,
                        verbose: 0
                    });
                    
                    console.log('Model retrained with', this.trainingData.length, 'samples');
                    this.trainingData = []; // Clear training data
                } catch (error) {
                    console.error('Retraining error:', error);
                }
            }

            // 12. Social & Community Features
            initializeCommunityFeatures() {
                this.communityEnabled = false;
                this.firebaseConfig = {
                    // Add your Firebase config here
                };
                
                // Initialize Firebase if config is provided
                if (this.firebaseConfig.apiKey) {
                    this.initializeFirebase();
                }
            }

            initializeFirebase() {
                try {
                    firebase.initializeApp(this.firebaseConfig);
                    this.database = firebase.database();
                    this.auth = firebase.auth();
                    this.communityEnabled = true;
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                }
            }

            async shareReading(reading) {
                const shareData = {
                    type: 'tarot-reading',
                    cards: reading.cards.map(c => ({ title: c.title, symbol: c.symbol })),
                    interpretation: reading.interpretation,
                    timestamp: Date.now(),
                    anonymous: true,
                    environment: this.currentEnvironment
                };
                
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'My Mystical Tarot Reading',
                            text: reading.interpretation,
                            url: window.location.href
                        });
                        this.showNotification('Reading shared successfully!', 'success');
                    } catch (error) {
                        this.fallbackShare(shareData);
                    }
                } else {
                    this.fallbackShare(shareData);
                }
            }

            fallbackShare(shareData) {
                const shareText = `Check out my tarot reading:\n\n${shareData.interpretation}`;
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareText);
                    this.showNotification('Reading copied to clipboard!', 'success');
                } else {
                    // Create temporary textarea for copying
                    const textarea = document.createElement('textarea');
                    textarea.value = shareText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    this.showNotification('Reading copied to clipboard!', 'success');
                }
            }

            async saveToCloud(reading) {
                if (!this.communityEnabled) return;
                
                try {
                    await this.database.ref('readings').push({
                        cards: reading.cards,
                        interpretation: reading.interpretation,
                        timestamp: Date.now(),
                        environment: this.currentEnvironment,
                        aiInsights: this.aiInsights
                    });
                    
                    this.showNotification('Reading saved to cloud!', 'success');
                } catch (error) {
                    console.error('Cloud save error:', error);
                    this.showNotification('Failed to save to cloud', 'error');
                }
            }

            // Continue with enhanced initialization and setup methods...
            initializeCanvases() {
                this.bgCanvas = document.getElementById('bg-canvas');
                this.canvas = document.getElementById('particle-canvas');
                this.glitterCanvas = document.getElementById('glitter-canvas');
                this.shineCanvas = document.getElementById('shine-canvas');
                this.trailCanvas = document.getElementById('trail-canvas');
                
                this.bgCtx = this.bgCanvas.getContext('2d');
                this.ctx = this.canvas.getContext('2d');
                this.glitterCtx = this.glitterCanvas.getContext('2d');
                this.shineCtx = this.shineCanvas.getContext('2d');
                this.trailCtx = this.trailCanvas.getContext('2d');
                
                this.setupCanvas();
            }

            initializeElements() {
                this.cardsContainer = document.getElementById("cards-container");
                this.messageContainer = document.getElementById("message-container");
                this.messageTitle = document.getElementById("message-title");
                this.messageText = document.getElementById("message-text");
                this.fortuneDetails = document.getElementById("fortune-details");
                this.drawCardsBtn = document.getElementById("draw-cards-btn");
                this.reshuffleBtn = document.getElementById("reshuffle-btn");
                this.shuffleBtn = document.getElementById("shuffle-btn");
                this.tarotSpreadBtn = document.getElementById("tarot-spread-btn");
                this.saveFortuneBtn = document.getElementById("save-fortune-btn");
                this.exportBtn = document.getElementById("export-btn");
                this.shareBtn = document.getElementById("share-btn");
                this.aiReadingBtn = document.getElementById("ai-reading-btn");
                this.loadingElement = document.getElementById("loading");
                this.spreadSelector = document.getElementById("spread-selector");
                this.customCursor = document.querySelector(".custom-cursor");
            }

            setupEventListeners() {
                // Original event listeners
                this.shuffleBtn.addEventListener('click', () => this.shuffleDeck());
                this.drawCardsBtn.addEventListener('click', () => this.drawCards());
                this.tarotSpreadBtn.addEventListener('click', () => this.toggleSpreadSelector());
                this.reshuffleBtn.addEventListener('click', () => this.reshuffleCards());
                this.saveFortuneBtn.addEventListener('click', () => this.saveFortune());
                this.exportBtn.addEventListener('click', () => this.exportFortunes());
                this.shareBtn.addEventListener('click', () => this.shareCurrentReading());
                this.aiReadingBtn.addEventListener('click', () => this.generateAIReading(this.selectedCards));
                
                // Enhanced controls
                document.getElementById('particle-intensity').addEventListener('input', (e) => {
                    this.particleIntensity = parseFloat(e.target.value);
                });
                
                document.getElementById('animation-speed').addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('ai-toggle').addEventListener('click', () => {
                    this.toggleAI();
                });
                
                document.getElementById('voice-toggle').addEventListener('click', () => {
                    this.toggleVoice();
                });
                
                document.getElementById('perf-toggle').addEventListener('click', () => {
                    this.togglePerformanceMonitor();
                });
                
                document.getElementById('voice-btn').addEventListener('click', () => {
                    this.startVoiceRecognition();
                });
                
                // Environment controls
                document.querySelectorAll('.env-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.switchEnvironment(e.target.dataset.env);
                    });
                });
                
                // Spread selector
                document.querySelectorAll('.spread-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.spread-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentSpread = e.target.dataset.spread;
                    });
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeCardPreview();
                        if (this.isRevealed) this.reshuffleCards();
                    }
                    if (e.key === ' ' && !this.isRevealed) {
                        e.preventDefault();
                        this.shuffleDeck();
                    }
                    if (e.key === 'Enter' && !this.isRevealed) {
                        this.drawCards();
                    }
                    if (e.key === 'a' && e.ctrlKey) {
                        e.preventDefault();
                        this.toggleAI();
                    }
                    if (e.key === 'v' && e.ctrlKey) {
                        e.preventDefault();
                        this.toggleVoice();
                    }
                });
            }

            // Toggle functions for enhanced controls
                        toggleAI() {
                this.aiEnabled = !this.aiEnabled;
                document.getElementById('ai-toggle').classList.toggle('active', this.aiEnabled);
                
                if (this.aiEnabled) {
                    this.showNotification('AI Analysis enabled', 'success');
                    document.getElementById('ai-analysis').classList.add('visible');
                } else {
                    this.showNotification('AI Analysis disabled', 'warning');
                    document.getElementById('ai-analysis').classList.remove('visible');
                }
            }

            toggleVoice() {
                this.voiceEnabled = !this.voiceEnabled;
                document.getElementById('voice-toggle').classList.toggle('active', this.voiceEnabled);
                
                if (this.voiceEnabled) {
                    this.showNotification('Voice Control enabled - Try saying "shuffle" or "draw"', 'success');
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                } else {
                    this.showNotification('Voice Control disabled', 'warning');
                }
            }

            togglePerformanceMonitor() {
                this.performanceMonitor.enabled = !this.performanceMonitor.enabled;
                document.getElementById('perf-toggle').classList.toggle('active', this.performanceMonitor.enabled);
                
                const monitor = document.getElementById('performance-monitor');
                if (this.performanceMonitor.enabled) {
                    monitor.classList.add('visible');
                    this.showNotification('Performance Monitor enabled', 'success');
                } else {
                    monitor.classList.remove('visible');
                    this.showNotification('Performance Monitor disabled', 'warning');
                }
            }

            // Environment navigation
            previousEnvironment() {
                const envs = Object.keys(this.environments);
                const currentIndex = envs.indexOf(this.currentEnvironment);
                const prevIndex = (currentIndex - 1 + envs.length) % envs.length;
                this.switchEnvironment(envs[prevIndex]);
            }

            nextEnvironment() {
                const envs = Object.keys(this.environments);
                const currentIndex = envs.indexOf(this.currentEnvironment);
                const nextIndex = (currentIndex + 1) % envs.length;
                this.switchEnvironment(envs[nextIndex]);
            }

            // Context menu for long press
            showContextMenu(x, y) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.position = 'fixed';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.style.background = 'rgba(0, 0, 0, 0.9)';
                menu.style.borderRadius = '10px';
                menu.style.padding = '10px';
                menu.style.zIndex = '10000';
                menu.style.backdropFilter = 'blur(10px)';
                menu.style.border = '2px solid var(--primary-color)';
                
                menu.innerHTML = `
                    <div class="context-item" data-action="shuffle">üîÑ Shuffle</div>
                    <div class="context-item" data-action="draw">‚ú® Draw</div>
                    <div class="context-item" data-action="ai">ü§ñ AI Reading</div>
                    <div class="context-item" data-action="voice">üé§ Voice</div>
                `;
                
                document.body.appendChild(menu);
                
                // Add event listeners
                menu.querySelectorAll('.context-item').forEach(item => {
                    item.style.padding = '8px 12px';
                    item.style.cursor = 'pointer';
                    item.style.borderRadius = '5px';
                    item.style.margin = '2px 0';
                    item.style.transition = 'background 0.3s ease';
                    
                    item.addEventListener('mouseenter', () => {
                        item.style.background = 'var(--primary-color)';
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'transparent';
                    });
                    
                    item.addEventListener('click', () => {
                        const action = item.dataset.action;
                        this.executeContextAction(action);
                        document.body.removeChild(menu);
                    });
                });
                
                // Remove menu on outside click
                setTimeout(() => {
                    document.addEventListener('click', () => {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                    }, { once: true });
                }, 100);
            }

            executeContextAction(action) {
                switch (action) {
                    case 'shuffle':
                        this.shuffleDeck();
                        break;
                    case 'draw':
                        this.drawCards();
                        break;
                    case 'ai':
                        this.generateAIReading(this.selectedCards);
                        break;
                    case 'voice':
                        this.startVoiceRecognition();
                        break;
                }
            }

            // Enhanced card reveal with AI
            async revealCard(x, y) {
                const card = this.findCardAt(x, y);
                if (card && !card.classList.contains('flipped')) {
                    card.classList.add('flipped');
                    
                    // Get card data
                    const cardData = this.currentDeck[parseInt(card.dataset.index)];
                    
                    // Generate AI prediction
                    if (this.aiEnabled) {
                        const accuracy = await this.predictReadingAccuracy([cardData]);
                        this.showNotification(`AI Prediction: ${Math.round(accuracy * 100)}% accuracy`, 'ai');
                    }
                    
                    // Create particles
                    const rect = card.getBoundingClientRect();
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            this.createParticle(rect.left + rect.width / 2, rect.top + rect.height / 2, 'reveal');
                        }, i * 50);
                    }
                    
                    // Play sound
                    this.playCardFlip();
                }
            }

            findCardAt(x, y) {
                const cards = document.querySelectorAll('.card');
                for (let card of cards) {
                    const rect = card.getBoundingClientRect();
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        return card;
                    }
                }
                return null;
            }

            // Enhanced sharing with AI insights
            async shareCurrentReading() {
                if (!this.selectedCards.length) {
                    this.showNotification('No reading to share', 'warning');
                    return;
                }
                
                const reading = {
                    cards: this.selectedCards.map(c => c.data),
                    interpretation: this.messageText.textContent,
                    environment: this.currentEnvironment,
                    timestamp: new Date().toISOString(),
                    aiInsights: this.aiEnabled ? this.aiInsights : null
                };
                
                await this.shareReading(reading);
                
                // Save to cloud if enabled
                if (this.communityEnabled) {
                    await this.saveToCloud(reading);
                }
            }

            // Enhanced custom cursor
            setupCustomCursor() {
                this.mousePos = { x: 0, y: 0 };
                this.cursorTrail = [];
                this.maxTrailLength = 20;
                
                document.addEventListener('mousemove', (e) => {
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                    
                    // Update cursor position
                    this.customCursor.style.left = e.clientX + 'px';
                    this.customCursor.style.top = e.clientY + 'px';
                    
                    // Update lighting
                    this.updateAmbientLighting(this.environments[this.currentEnvironment].ambientColor);
                    
                    // Add to trail
                    this.cursorTrail.push({ x: e.clientX, y: e.clientY, time: Date.now() });
                    if (this.cursorTrail.length > this.maxTrailLength) {
                        this.cursorTrail.shift();
                    }
                    
                    // Create trail particles occasionally
                    if (Math.random() < 0.3) {
                        this.createParticle(e.clientX, e.clientY, 'cursor');
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    this.customCursor.classList.add('active');
                });
                
                document.addEventListener('mouseup', () => {
                    this.customCursor.classList.remove('active');
                });
                
                // Hide cursor when leaving window
                document.addEventListener('mouseleave', () => {
                    this.customCursor.style.opacity = '0';
                });
                
                document.addEventListener('mouseenter', () => {
                    this.customCursor.style.opacity = '1';
                });
            }

            // Enhanced notification system
            showNotification(message, type = 'info') {
                const container = document.getElementById('notification-container');
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                // Add icon based on type
                const icons = {
                    success: '‚úÖ',
                    warning: '‚ö†Ô∏è',
                    error: '‚ùå',
                    info: '‚ÑπÔ∏è',
                    ai: 'ü§ñ'
                };
                
                notification.innerHTML = `
                    <span class="notification-icon">${icons[type] || icons.info}</span>
                    <span class="notification-text">${message}</span>
                    <button class="notification-close" onclick="this.parentElement.remove()">√ó</button>
                `;
                
                container.appendChild(notification);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.style.animation = 'notificationSlide 0.5s ease-out reverse';
                        setTimeout(() => notification.remove(), 500);
                    }
                }, 5000);
                
                // Create notification particles
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            window.innerWidth - 200 + Math.random() * 100,
                            50 + Math.random() * 50,
                            'notification'
                        );
                    }, i * 100);
                }
            }

            // Enhanced initialization
            async init() {
                this.showLoading();
                
                // Initialize all systems
                await this.delay(1000);
                this.createGlitterBackground();
                this.setupAmbientEffects();
                this.generateProceduralMusic();
                
                // Start animation loops
                this.animate();
                this.animateGlitter();
                this.animateShine();
                
                // Initial shuffle
                await this.shuffleDeck();
                
                this.hideLoading();
                
                // Welcome message
                this.showNotification('Welcome to Ultimate Mystical Tarot! üîÆ', 'success');
                
                // Voice introduction
                if (this.voiceEnabled) {
                    setTimeout(() => {
                        this.speakResponse("Welcome to your mystical tarot experience. Say shuffle to begin.");
                    }, 2000);
                }
            }

            // Enhanced animation loop with performance monitoring
            animate() {
                this.updatePerformanceMetrics();
                
                // Clear canvases
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.trailCtx.clearRect(0, 0, this.trailCanvas.width, this.trailCanvas.height);
                
                // Apply force fields
                this.applyForceFields();
                
                // Update and render particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    // Update particle
                    p.x += p.vx * this.animationSpeed;
                    p.y += p.vy * this.animationSpeed;
                    p.life -= this.animationSpeed;
                    p.rotation += p.rotationSpeed * this.animationSpeed;
                    
                    // Boundary checks
                    if (p.x < 0 || p.x > this.canvas.width || p.y < 0 || p.y > this.canvas.height) {
                        p.life = 0;
                    }
                    
                    // Render particle
                    if (p.life > 0) {
                        const alpha = p.life / p.maxLife;
                        
                        this.ctx.save();
                        this.ctx.translate(p.x, p.y);
                        this.ctx.rotate(p.rotation);
                        this.ctx.globalAlpha = alpha;
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = p.color;
                        this.ctx.fillStyle = p.color;
                        this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                        this.ctx.restore();
                    } else {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Render cursor trail
                this.renderCursorTrail();
                
                // Limit particle count for performance
                if (this.particles.length > this.maxParticles) {
                    this.particles.splice(0, this.particles.length - this.maxParticles);
                }
                
                requestAnimationFrame(() => this.animate());
            }

            renderCursorTrail() {
                if (this.cursorTrail.length < 2) return;
                
                this.trailCtx.strokeStyle = this.environments[this.currentEnvironment].particles;
                this.trailCtx.lineWidth = 3;
                this.trailCtx.lineCap = 'round';
                this.trailCtx.shadowBlur = 10;
                this.trailCtx.shadowColor = this.environments[this.currentEnvironment].particles;
                
                this.trailCtx.beginPath();
                this.trailCtx.moveTo(this.cursorTrail[0].x, this.cursorTrail[0].y);
                
                for (let i = 1; i < this.cursorTrail.length; i++) {
                    const point = this.cursorTrail[i];
                    const age = Date.now() - point.time;
                    const alpha = Math.max(0, 1 - age / 2000);
                    
                    this.trailCtx.globalAlpha = alpha;
                    this.trailCtx.lineTo(point.x, point.y);
                }
                
                this.trailCtx.stroke();
                this.trailCtx.globalAlpha = 1;
                
                // Clean up old trail points
                this.cursorTrail = this.cursorTrail.filter(point => Date.now() - point.time < 2000);
            }

            // Original methods with enhancements
            initializeData() {
                this.availableCards = [
                    { 
                        symbol: "‚≠ê", 
                        title: "The Star", 
                        description: "Hope, inspiration, and spiritual guidance",
                        fortune: "A period of hope and healing approaches. Trust in the universe's plan for you.",
                        rarity: "major",
                        element: "Air",
                        numerology: 17
                    },
                    { 
                        symbol: "üåô", 
                        title: "The Moon", 
                        description: "Intuition, mystery, and subconscious realms",
                        fortune: "Listen to your inner voice. Not everything is as it seems.",
                        rarity: "major",
                        element: "Water",
                        numerology: 18
                    },
                    // ... Continue with all 78 cards
                ];
            }

            initializeState() {
                this.currentDeck = [];
                this.selectedCards = [];
                this.isShuffling = false;
                this.isRevealed = false;
                this.savedFortunes = JSON.parse(localStorage.getItem('mysticalFortunes') || '[]');
                this.currentSpread = 'three-card';
                this.particleIntensity = 1;
                this.animationSpeed = 1;
                this.maxParticles = 300;
                this.particles = [];
                this.glitterParticles = [];
                this.shineParticles = [];
                
                this.spreadTypes = {
                    'three-card': {
                        name: 'Three Card Spread',
                        positions: [
                            { x: -120, y: 0, rotation: -10, name: 'Past' },
                            { x: 0, y: 0, rotation: 0, name: 'Present' },
                            { x: 120, y: 0, rotation: 10, name: 'Future' }
                        ]
                    },
                    'five-card': {
                        name: 'Five Card Cross',
                        positions: [
                            { x: 0, y: -80, rotation: 0, name: 'Spirit' },
                            { x: -80, y: 0, rotation: -15, name: 'Challenge' },
                            { x: 0, y: 0, rotation: 0, name: 'Focus' },
                            { x: 80, y: 0, rotation: 15, name: 'Action' },
                            { x: 0, y: 80, rotation: 0, name: 'Outcome' }
                        ]
                    },
                    'celtic-cross': {
                        name: 'Celtic Cross',
                        positions: [
                            { x: 0, y: 0, rotation: 0, name: 'Present' },
                            { x: 0, y: 0, rotation: 90, name: 'Challenge' },
                            { x: 0, y: -120, rotation: 0, name: 'Distant Past' },
                            { x: 0, y: 120, rotation: 0, name: 'Possible Future' },
                            { x: -120, y: 0, rotation: 0, name: 'Recent Past' },
                            { x: 120, y: 0, rotation: 0, name: 'Near Future' },
                            { x: 200, y: 120, rotation: 0, name: 'Your Approach' },
                            { x: 200, y: 60, rotation: 0, name: 'External Influences' },
                            { x: 200, y: 0, rotation: 0, name: 'Hopes & Fears' },
                            { x: 200, y: -60, rotation: 0, name: 'Final Outcome' }
                        ]
                    }
                };
                
                this.particleColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            }

            // Continue with all other methods...
            setupCanvas() {
                const canvases = [this.bgCanvas, this.canvas, this.glitterCanvas, this.shineCanvas, this.trailCanvas];
                
                canvases.forEach(canvas => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
                
                // Setup background
                this.createStarryBackground();
                
                // Resize handler
                window.addEventListener('resize', () => {
                    canvases.forEach(canvas => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    });
                    this.createStarryBackground();
                });
            }

            createStarryBackground() {
                const ctx = this.bgCtx;
                ctx.fillStyle = 'var(--bg-color)';
                ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                
                // Create stars
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * this.bgCanvas.width;
                    const y = Math.random() * this.bgCanvas.height;
                    const size = Math.random() * 2;
                    const opacity = Math.random() * 0.8 + 0.2;
                    
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Additional helper methods
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            showLoading() {
                this.loadingElement.style.display = 'block';
                this.loadingElement.classList.add('animate__animated', 'animate__fadeIn');
            }

            hideLoading() {
                this.loadingElement.classList.add('animate__animated', 'animate__fadeOut');
                setTimeout(() => {
                    this.loadingElement.style.display = 'none';
                    this.loadingElement.classList.remove('animate__animated', 'animate__fadeIn', 'animate__fadeOut');
                }, 500);
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Continue with all original methods like shuffleDeck, drawCards, etc.
            // ... (Include all the original methods from the previous implementation)
        }

        // Gesture Recognition Helper Class
        class GestureRecognizer {
            constructor() {
                this.gestures = new Map();
                this.threshold = 50;
                this.timeThreshold = 1000;
            }

            addGesture(name, callback) {
                this.gestures.set(name, callback);
            }

            recognizeGesture(startX, startY, endX, endY, duration) {
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance < this.threshold) {
                    if (duration > this.timeThreshold) {
                        return 'long-press';
                    }
                    return 'tap';
                }
                
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                if (Math.abs(angle) < 45) return 'swipe-right';
                if (Math.abs(angle - 180) < 45) return 'swipe-left';
                if (angle > 45 && angle < 135) return 'swipe-down';
                if (angle < -45 && angle > -135) return 'swipe-up';
                
                return 'unknown';
            }
        }

        // Initialize the enhanced application
        document.addEventListener('DOMContentLoaded', () => {
            new UltimateMysticalTarot();
        });

        // Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>
</body>
</html>

